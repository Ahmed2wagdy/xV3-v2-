Directory structure:
└── src/
    ├── index.html
    ├── main.server.ts
    ├── main.ts
    ├── run.bat
    ├── styles.css
    ├── app/
    │   ├── app.component.css
    │   ├── app.component.html
    │   ├── app.component.spec.ts
    │   ├── app.component.ts
    │   ├── app.config.server.ts
    │   ├── app.config.ts
    │   ├── app.routes.ts
    │   ├── index.ts
    │   ├── add-property/
    │   │   ├── add-property.component.css
    │   │   ├── add-property.component.html
    │   │   ├── add-property.component.spec.ts
    │   │   └── add-property.component.ts
    │   ├── chat-bot/
    │   │   ├── chat-bot.component.css
    │   │   ├── chat-bot.component.html
    │   │   ├── chat-bot.component.spec.ts
    │   │   └── chat-bot.component.ts
    │   ├── favorites/
    │   │   ├── favorites.component.css
    │   │   ├── favorites.component.html
    │   │   ├── favorites.component.spec.ts
    │   │   └── favorites.component.ts
    │   ├── filters/
    │   │   ├── filters.component.css
    │   │   ├── filters.component.html
    │   │   ├── filters.component.spec.ts
    │   │   └── filters.component.ts
    │   ├── forget-pass/
    │   │   ├── forget-pass.component.css
    │   │   ├── forget-pass.component.html
    │   │   ├── forget-pass.component.spec.ts
    │   │   └── forget-pass.component.ts
    │   ├── guards/
    │   │   └── auth.guard.ts
    │   ├── home/
    │   │   ├── home.component.css
    │   │   ├── home.component.html
    │   │   ├── home.component.spec.ts
    │   │   └── home.component.ts
    │   ├── interceptors/
    │   │   └── auth.interceptor.ts
    │   ├── log-in/
    │   │   ├── log-in.component.css
    │   │   ├── log-in.component.html
    │   │   ├── log-in.component.spec.ts
    │   │   └── log-in.component.ts
    │   ├── models/
    │   │   ├── property.model.ts
    │   │   └── user.model.ts
    │   ├── otp-verification/
    │   │   ├── otp-verification.component.css
    │   │   ├── otp-verification.component.html
    │   │   ├── otp-verification.component.spec.ts
    │   │   └── otp-verification.component.ts
    │   ├── payment/
    │   │   ├── payment.component.css
    │   │   ├── payment.component.html
    │   │   ├── payment.component.spec.ts
    │   │   └── payment.component.ts
    │   ├── profile/
    │   │   ├── profile.component.css
    │   │   ├── profile.component.html
    │   │   ├── profile.component.spec.ts
    │   │   └── profile.component.ts
    │   ├── property-detail/
    │   │   ├── property-detail.component.css
    │   │   ├── property-detail.component.html
    │   │   ├── property-detail.component.spec.ts
    │   │   └── property-detail.component.ts
    │   ├── reset-password/
    │   │   ├── reset-password.component.css
    │   │   ├── reset-password.component.html
    │   │   ├── reset-password.component.spec.ts
    │   │   └── reset-password.component.ts
    │   ├── services/
    │   │   ├── amenities.service.ts
    │   │   ├── auth.service.ts
    │   │   ├── payment.service.ts
    │   │   └── property.service.ts
    │   └── sign-up/
    │       ├── sign-up.component.css
    │       ├── sign-up.component.html
    │       ├── sign-up.component.spec.ts
    │       └── sign-up.component.ts
    └── assets/
        ├── .gitkeep
        └── images/
            └── background.webp

================================================
File: index.html
================================================
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Xv3</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
<script src="https://js.stripe.com/v3/"></script>

</head>
<body>
  <app-root></app-root>
</body>
</html>


================================================
File: main.server.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { config } from './app/app.config.server';

const bootstrap = () => bootstrapApplication(AppComponent, config);

export default bootstrap;



================================================
File: main.ts
================================================
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));


================================================
File: run.bat
================================================
@echo off
REM Batch script to run back.py from the current directory
gitingest . --exclude-pattern "digest.txt"

IF EXIST back.py (
    python back.py
) ELSE (
    echo Error: back.py not found in the current directory.
)



================================================
File: styles.css
================================================
/* أضف هذا في ملف styles.css العام للتطبيق */

/* تحديد اللون الأساسي للتطبيق */
:root {
    --primary-color: #08227B;
  }
  
  /* أنماط الأزرار الأساسية */
  .btn-primary {
    background-color: #08227B !important;
    border-color: #08227B !important;
    color: white !important;
  }
  
  .btn-outline-primary {
    color: #08227B !important;
    border-color: #08227B !important;
  }
  
  .btn-outline-primary:hover {
    background-color: #08227B !important;
    border-color: #08227B !important;
    color: white !important;
  }
  
  /* تنسيقات SweetAlert2 */
  .swal2-icon.swal2-info {
    color: #08227B !important;
    border-color: #08227B !important;
  }
  
  .swal2-styled.swal2-confirm {
    background-color: #08227B !important;
  }


================================================
File: app/app.component.css
================================================



================================================
File: app/app.component.html
================================================
<!-- app.compnent.html-->
<router-outlet></router-outlet><!-- Check if your app.component.html has this router-outlet tag -->



================================================
File: app/app.component.spec.ts
================================================
//app.component.spec.ts
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'xv3' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('xv3');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, xv3');
  });
});



================================================
File: app/app.component.ts
================================================
//app.component.ts
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [RouterOutlet],
  template: `<router-outlet></router-outlet>`,
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Dizon';
}


================================================
File: app/app.config.server.ts
================================================
//app.config.server.ts
import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';
import { provideServerRendering } from '@angular/platform-server';
import { appConfig } from './app.config';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering()
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);



================================================
File: app/app.config.ts
================================================
import { ApplicationConfig } from '@angular/core';
import { provideRouter } from '@angular/router';
import { routes } from './app.routes';
import { provideHttpClient, withInterceptors, withFetch } from '@angular/common/http';
import { authInterceptor } from './interceptors/auth.interceptor';
import { CookieService } from 'ngx-cookie-service';
import { AuthService } from './services/auth.service';
import { PropertyService } from './services/property.service';
import { AmenitiesService } from './services/amenities.service';
import { PaymentService } from './services/payment.service';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(
      withFetch(),
      withInterceptors([authInterceptor])
    ),
    CookieService,
    AuthService,
    PropertyService,
    AmenitiesService,
    PaymentService
  ]
};



================================================
File: app/app.routes.ts
================================================
import { Routes } from '@angular/router';
import { 
  LogInComponent,
  ForgetPassComponent,
  OtpVerificationComponent,
  ResetPasswordComponent,
  HomeComponent
} from './index';
import { SignUpComponent } from './sign-up/sign-up.component';
import { AddPropertyComponent } from './add-property/add-property.component';
import { FavoritesComponent } from './favorites/favorites.component';
import { ChatBotComponent } from './chat-bot/chat-bot.component';
import { PropertyDetailComponent } from './property-detail/property-detail.component';
import { ProfileComponent } from './profile/profile.component';
import { authGuard } from './guards/auth.guard';

export const routes: Routes = [
  // Default route redirects to login
  { path: '', redirectTo: '/log-in', pathMatch: 'full' },
  
  // Authentication routes
  { path: 'log-in', component: LogInComponent },
  { path: 'sign-up', component: SignUpComponent },
  { path: 'forget-pass', component: ForgetPassComponent },
  { path: 'otp-verification', component: OtpVerificationComponent },
  { path: 'reset-password', component: ResetPasswordComponent },
  
  // Protected routes
  { path: 'home', component: HomeComponent, canActivate: [authGuard] },
  { path: 'property/:id', component: PropertyDetailComponent, canActivate: [authGuard] },
  { path: 'add-property', component: AddPropertyComponent, canActivate: [authGuard] },
  { path: 'favorites', component: FavoritesComponent, canActivate: [authGuard] },
  { path: 'chat-bot', component: ChatBotComponent, canActivate: [authGuard] },
  { path: 'profile', component: ProfileComponent, canActivate: [authGuard] },
  
  // Wildcard route
  { path: '**', redirectTo: '/log-in' }
];


================================================
File: app/index.ts
================================================
// app/index.ts
// Export all components for easy imports
export * from './log-in/log-in.component';
export * from './sign-up/sign-up.component';
export * from './forget-pass/forget-pass.component';
export * from './otp-verification/otp-verification.component';
export * from './reset-password/reset-password.component';
export * from './home/home.component';
export * from './property-detail/property-detail.component';


================================================
File: app/add-property/add-property.component.css
================================================
  
.payment-notice {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 0;
  }

  .payment-info-card {
    padding: 20px;
    background: white;
    border: 2px solid #08227B;
    border-radius: 8px;
    position: relative;
  }

  .payment-info-card::before {
    content: '';
    position: absolute;
    top: -1px;
    left: -1px;
    right: -1px;
    bottom: -1px;
    background: linear-gradient(45deg, #08227B, #061a5f);
    border-radius: 8px;
    z-index: -1;
  }

  .payment-icon {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #08227B, #061a5f);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 20px;
    flex-shrink: 0;
  }

  .payment-icon i {
    font-size: 24px;
    color: white;
  }

  .payment-content h5 {
    color: #08227B;
    margin-bottom: 8px;
    font-weight: 600;
  }

  .payment-content p {
    color: #333;
    margin-bottom: 5px;
  }

  .modal {
    background: rgba(0, 0, 0, 0.5);
  }

  .modal.show {
    display: block !important;
  }

  .modal-backdrop {
    background: rgba(0, 0, 0, 0.5);
  }

  .modal-backdrop.show {
    opacity: 1;
  }

  .image-preview-card {
    position: relative;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .image-preview-card:hover {
    border-color: #08227B;
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(8, 34, 123, 0.2);
  }

  .image-preview-card img {
    width: 100%;
    height: 150px;
    object-fit: cover;
  }

  .remove-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 25px;
    height: 25px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .image-preview-card:hover .remove-btn {
    opacity: 1;
  }

  .form-section {
    background: white;
    border: 1px solid #e9ecef;
    border-radius: 10px;
    padding: 25px;
    margin-bottom: 25px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  }

  .section-title {
    color: #08227B;
    font-weight: 600;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 2px solid #f8f9fa;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .section-title::before {
    content: '';
    width: 4px;
    height: 25px;
    background: linear-gradient(135deg, #08227B, #061a5f);
    border-radius: 2px;
  }

  .amenities-group {
    margin-bottom: 25px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #e9ecef;
  }

  .amenities-subtitle {
    color: #495057;
    font-weight: 600;
    margin-bottom: 15px;
    font-size: 16px;
  }

  .form-check-input:checked {
    background-color: #08227B;
    border-color: #08227B;
  }

  .form-check-input:focus {
    border-color: #08227B;
    outline: 0;
    box-shadow: 0 0 0 0.25rem rgba(8, 34, 123, 0.25);
  }

  .btn-primary {
    background: linear-gradient(135deg, #08227B, #061a5f);
    border: none;
    font-weight: 600;
    padding: 12px 30px;
    border-radius: 8px;
    transition: all 0.3s ease;
  }

  .btn-primary:hover {
    background: linear-gradient(135deg, #061a5f, #08227B);
    transform: translateY(-1px);
    box-shadow: 0 4px 15px rgba(8, 34, 123, 0.3);
  }

  .btn-secondary {
    background: #6c757d;
    border: none;
    font-weight: 600;
    padding: 12px 30px;
    border-radius: 8px;
    transition: all 0.3s ease;
  }

  .btn-secondary:hover {
    background: #5a6268;
    transform: translateY(-1px);
  }

  @media (max-width: 768px) {
    .form-section {
      padding: 20px;
      margin-bottom: 20px;
    }

    .payment-info-card {
      padding: 15px;
    }

    .payment-icon {
      width: 50px;
      height: 50px;
      margin-right: 15px;
    }

    .payment-icon i {
      font-size: 20px;
    }

    .amenities-group {
      padding: 15px;
    }

    .modal-dialog {
      margin: 10px;
    }

    .image-preview-card img {
      height: 120px;
    }
  }


================================================
File: app/add-property/add-property.component.html
================================================
<!-- Add Property Component HTML with Payment Integration -->
<div class="container py-4">
  <!-- Header -->
  <div class="d-flex justify-content-between align-items-center mb-4">
    <h1 class="page-title">Add New Property</h1>
    <button class="btn btn-outline-secondary" (click)="goBack()">
      <i class="bi bi-arrow-left"></i> Back
    </button>
  </div>

  <!-- Payment Status Alert -->
  <div *ngIf="paymentCompleted" class="alert alert-success d-flex align-items-center mb-4">
    <i class="bi bi-check-circle-fill me-2"></i>
    <div>
      <strong>Payment Successful!</strong> Your payment has been processed. Now completing property listing...
    </div>
  </div>

  <!-- Loading State -->
  <div *ngIf="isLoading" class="text-center py-5">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-3">Loading amenities...</p>
  </div>

  <!-- Main Form -->
  <div *ngIf="!isLoading" class="row">
    <div class="col-12">
      <form [formGroup]="propertyForm" (ngSubmit)="onSubmit()" class="property-form">
        
        <!-- Basic Information Section -->
        <div class="form-section">
          <h3 class="section-title">Basic Information</h3>
          
          <div class="row">
            <div class="col-md-8">
              <div class="mb-3">
                <label for="title" class="form-label">Property Title *</label>
                <input 
                  type="text" 
                  id="title"
                  formControlName="title" 
                  class="form-control"
                  [class.is-invalid]="submitted && f['title'].errors"
                  placeholder="e.g., Modern 3BR Apartment in Cairo"
                >
                <div *ngIf="submitted && f['title'].errors" class="invalid-feedback">
                  <div *ngIf="f['title'].errors['required']">Property title is required</div>
                  <div *ngIf="f['title'].errors['minlength']">Title must be at least 3 characters</div>
                </div>
              </div>
            </div>
            
            <div class="col-md-4">
              <div class="mb-3">
                <label for="price" class="form-label">Price (EGP) *</label>
                <input 
                  type="number" 
                  id="price"
                  formControlName="price" 
                  class="form-control"
                  [class.is-invalid]="submitted && f['price'].errors"
                  placeholder="e.g., 250000"
                >
                <div *ngIf="submitted && f['price'].errors" class="invalid-feedback">
                  <div *ngIf="f['price'].errors['required']">Price is required</div>
                  <div *ngIf="f['price'].errors['min']">Price must be greater than 0</div>
                </div>
              </div>
            </div>
          </div>

          <div class="mb-3">
            <label for="description" class="form-label">Description *</label>
            <textarea 
              id="description"
              formControlName="description" 
              class="form-control"
              rows="4"
              [class.is-invalid]="submitted && f['description'].errors"
              placeholder="Describe your property, its features, and what makes it special..."
            ></textarea>
            <div *ngIf="submitted && f['description'].errors" class="invalid-feedback">
              <div *ngIf="f['description'].errors['required']">Description is required</div>
              <div *ngIf="f['description'].errors['minlength']">Description must be at least 10 characters</div>
            </div>
          </div>
        </div>

        <!-- Property Details Section -->
        <div class="form-section">
          <h3 class="section-title">Property Details</h3>
          
          <div class="row">
            <div class="col-md-6">
              <div class="mb-3">
                <label for="propertyType" class="form-label">Property Type *</label>
                <select 
                  id="propertyType"
                  formControlName="propertyType" 
                  class="form-select"
                  [class.is-invalid]="submitted && f['propertyType'].errors"
                >
                  <option value="">Select property type</option>
                  <option *ngFor="let type of propertyTypes" [value]="type">{{ type }}</option>
                </select>
                <div *ngIf="submitted && f['propertyType'].errors" class="invalid-feedback">
                  Property type is required
                </div>
              </div>
            </div>
            
            <div class="col-md-6">
              <div class="mb-3">
                <label for="size" class="form-label">Size (mÂ²) *</label>
                <input 
                  type="number" 
                  id="size"
                  formControlName="size" 
                  class="form-control"
                  [class.is-invalid]="submitted && f['size'].errors"
                  placeholder="e.g., 120"
                >
                <div *ngIf="submitted && f['size'].errors" class="invalid-feedback">
                  <div *ngIf="f['size'].errors['required']">Size is required</div>
                  <div *ngIf="f['size'].errors['min']">Size must be greater than 0</div>
                </div>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="col-md-6">
              <div class="mb-3">
                <label for="bedrooms" class="form-label">Bedrooms *</label>
                <input 
                  type="number" 
                  id="bedrooms"
                  formControlName="bedrooms" 
                  class="form-control"
                  [class.is-invalid]="submitted && f['bedrooms'].errors"
                  placeholder="e.g., 3"
                  min="0"
                >
                <div *ngIf="submitted && f['bedrooms'].errors" class="invalid-feedback">
                  <div *ngIf="f['bedrooms'].errors['required']">Number of bedrooms is required</div>
                  <div *ngIf="f['bedrooms'].errors['min']">Bedrooms cannot be negative</div>
                </div>
              </div>
            </div>
            
            <div class="col-md-6">
              <div class="mb-3">
                <label for="bathrooms" class="form-label">Bathrooms *</label>
                <input 
                  type="number" 
                  id="bathrooms"
                  formControlName="bathrooms" 
                  class="form-control"
                  [class.is-invalid]="submitted && f['bathrooms'].errors"
                  placeholder="e.g., 2"
                  min="1"
                >
                <div *ngIf="submitted && f['bathrooms'].errors" class="invalid-feedback">
                  <div *ngIf="f['bathrooms'].errors['required']">Number of bathrooms is required</div>
                  <div *ngIf="f['bathrooms'].errors['min']">At least 1 bathroom is required</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Location Section -->
        <div class="form-section">
          <h3 class="section-title">Location</h3>
          
          <div class="row">
            <div class="col-md-4">
              <div class="mb-3">
                <label for="governate" class="form-label">Governorate *</label>
                <select 
                  id="governate"
                  formControlName="governate" 
                  class="form-select"
                  [class.is-invalid]="submitted && f['governate'].errors"
                >
                  <option value="">Select governorate</option>
                  <option *ngFor="let gov of governorates" [value]="gov">{{ gov }}</option>
                </select>
                <div *ngIf="submitted && f['governate'].errors" class="invalid-feedback">
                  Governorate is required
                </div>
              </div>
            </div>
            
            <div class="col-md-4">
              <div class="mb-3">
                <label for="city" class="form-label">City *</label>
                <select 
                  id="city"
                  formControlName="city" 
                  class="form-select"
                  [class.is-invalid]="submitted && f['city'].errors"
                >
                  <option value="">Select city</option>
                  <option *ngFor="let city of cities" [value]="city">{{ city }}</option>
                </select>
                <div *ngIf="submitted && f['city'].errors" class="invalid-feedback">
                  City is required
                </div>
              </div>
            </div>
            
            <div class="col-md-4">
              <div class="mb-3">
                <label for="street" class="form-label">Street Address *</label>
                <input 
                  type="text" 
                  id="street"
                  formControlName="street" 
                  class="form-control"
                  [class.is-invalid]="submitted && f['street'].errors"
                  placeholder="e.g., 123 Tahrir Street"
                >
                <div *ngIf="submitted && f['street'].errors" class="invalid-feedback">
                  Street address is required
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Images Section -->
        <div class="form-section">
          <h3 class="section-title">Property Images</h3>
          
          <div class="mb-3">
            <label for="images" class="form-label">Upload Images (Max 10) *</label>
            <input 
              type="file" 
              id="images"
              class="form-control"
              accept="image/*"
              multiple
              (change)="onImageFilesSelected($event)"
            >
            <div class="form-text">Select multiple images to showcase your property. Supported formats: JPG, PNG, WebP</div>
          </div>

          <!-- Image Previews -->
          <div *ngIf="imagePreviews.length > 0" class="image-previews">
            <div class="row g-3">
              <div class="col-md-3" *ngFor="let preview of imagePreviews; let i = index">
                <div class="image-preview-card">
                  <img [src]="preview" class="img-fluid rounded" alt="Property image">
                  <button type="button" class="btn btn-danger btn-sm remove-btn" (click)="removeImage(i)">
                    <i class="bi bi-x"></i>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Amenities Section -->
        <div class="form-section">
          <h3 class="section-title">Amenities & Features</h3>
          
          <!-- Internal Amenities -->
          <div class="amenities-group">
            <h5 class="amenities-subtitle">Internal Amenities</h5>
            <div class="row">
              <div class="col-md-4" *ngFor="let amenity of internalAmenities">
                <div class="form-check mb-2">
                  <input 
                    class="form-check-input" 
                    type="checkbox" 
                    [id]="'internal-' + amenity.amenityId"
                    [checked]="isAmenitySelected(amenity.amenityId, 'internal')"
                    (change)="onAmenityChange($event, amenity.amenityId, 'internal')"
                  >
                  <label class="form-check-label" [for]="'internal-' + amenity.amenityId">
                    {{ amenity.name }}
                  </label>
                </div>
              </div>
            </div>
          </div>

          <!-- External Amenities -->
          <div class="amenities-group">
            <h5 class="amenities-subtitle">External Amenities</h5>
            <div class="row">
              <div class="col-md-4" *ngFor="let amenity of externalAmenities">
                <div class="form-check mb-2">
                  <input 
                    class="form-check-input" 
                    type="checkbox" 
                    [id]="'external-' + amenity.amenityId"
                    [checked]="isAmenitySelected(amenity.amenityId, 'external')"
                    (change)="onAmenityChange($event, amenity.amenityId, 'external')"
                  >
                  <label class="form-check-label" [for]="'external-' + amenity.amenityId">
                    {{ amenity.name }}
                  </label>
                </div>
              </div>
            </div>
          </div>

          <!-- Accessibility Features -->
          <div class="amenities-group">
            <h5 class="amenities-subtitle">Accessibility Features</h5>
            <div class="row">
              <div class="col-md-4" *ngFor="let amenity of accessibilityAmenities">
                <div class="form-check mb-2">
                  <input 
                    class="form-check-input" 
                    type="checkbox" 
                    [id]="'accessibility-' + amenity.amenityId"
                    [checked]="isAmenitySelected(amenity.amenityId, 'accessibility')"
                    (change)="onAmenityChange($event, amenity.amenityId, 'accessibility')"
                  >
                  <label class="form-check-label" [for]="'accessibility-' + amenity.amenityId">
                    {{ amenity.name }}
                  </label>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Payment Notice Section -->
        <div class="form-section payment-notice">
          <div class="payment-info-card">
            <div class="d-flex align-items-center">
              <div class="payment-icon">
                <i class="bi bi-credit-card"></i>
              </div>
              <div class="payment-content">
                <h5>Property Listing Fee</h5>
                <p class="mb-0">A one-time fee of <strong>${{ paymentAmount }}</strong> is required to list your property on our platform.</p>
                <small class="text-muted">Secure payment powered by Stripe</small>
              </div>
            </div>
          </div>
        </div>

        <!-- Submit Section -->
        <div class="form-section">
          <div class="d-flex justify-content-between">
            <button type="button" class="btn btn-secondary" (click)="goBack()" [disabled]="isSubmitting">
              Cancel
            </button>
            
            <button type="submit" class="btn btn-primary btn-lg" [disabled]="isSubmitting">
              <span *ngIf="!isSubmitting">
                <i class="bi bi-credit-card"></i> Proceed to Payment
              </span>
              <span *ngIf="isSubmitting">
                <span class="spinner-border spinner-border-sm me-2"></span>
                Processing...
              </span>
            </button>
          </div>
        </div>

      </form>
    </div>
  </div>
</div>

<!-- Payment Modal -->
<div class="modal" [class.show]="showPaymentModal" [style.display]="showPaymentModal ? 'block' : 'none'">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">
          <i class="bi bi-credit-card"></i>
          Complete Payment
        </h5>
        <button type="button" class="btn-close" (click)="onPaymentCancel()"></button>
      </div>
      <div class="modal-body p-0">
        <app-payment
          [showPayment]="showPaymentModal"
          [paymentAmount]="paymentAmount"
          (paymentSuccess)="onPaymentSuccess($event)"
          (paymentCancel)="onPaymentCancel()">
        </app-payment>
      </div>
    </div>
  </div>
</div>

<!-- Modal Backdrop -->
<div class="modal-backdrop" 
     [class.show]="showPaymentModal" 
     [style.display]="showPaymentModal ? 'block' : 'none'"
     (click)="onPaymentCancel()">
</div>




================================================
File: app/add-property/add-property.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { AddPropertyComponent } from './add-property.component';

describe('AddPropertyComponent', () => {
  let component: AddPropertyComponent;
  let fixture: ComponentFixture<AddPropertyComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AddPropertyComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(AddPropertyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/add-property/add-property.component.ts
================================================
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators, FormArray } from '@angular/forms';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import Swal from 'sweetalert2';
import { PropertyService } from '../services/property.service';
import { AmenitiesService, Amenity, AmenityType } from '../services/amenities.service';
import { AuthService } from '../services/auth.service';
import { PaymentComponent } from '../payment/payment.component';

@Component({
  selector: 'app-add-property',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, PaymentComponent],
  templateUrl: './add-property.component.html',
  styleUrls: ['./add-property.component.css']
})
export class AddPropertyComponent implements OnInit, OnDestroy {
  propertyForm!: FormGroup;
  submitted = false;
  isLoading = false;
  isSubmitting = false;
  
  // Payment related
  showPaymentModal = false;
  paymentAmount = 50; // Property listing fee in USD
  paymentCompleted = false;
  paymentData: any = null;
  
  // Amenities data
  internalAmenities: Amenity[] = [];
  externalAmenities: Amenity[] = [];
  accessibilityAmenities: Amenity[] = [];
  
  // Image preview
  imageFiles: File[] = [];
  imagePreviews: string[] = [];
  
  // Property types
  propertyTypes = ['Apartment', 'House', 'Villa', 'Office', 'Commercial', 'Land'];
  
  // Egyptian cities
  cities = [
    'Cairo', 'Alexandria', 'Giza', 'Shubra El Kheima', 'Port Said',
    'Suez', 'Luxor', 'Mansoura', 'El Mahalla El Kubra', 'Tanta',
    'Asyut', 'Ismailia', 'Fayyum', 'Zagazig', 'Aswan',
    'Damietta', 'Damanhur', 'Minya', 'Beni Suef', 'Qena',
    'Sohag', 'Hurghada', 'Sharm El Sheikh'
  ];
  
  // Governorates
  governorates = [
    'Cairo', 'Alexandria', 'Giza', 'Qalyubia', 'Port Said',
    'Suez', 'Luxor', 'Dakahlia', 'Gharbia', 'Monufia',
    'Asyut', 'Ismailia', 'Fayyum', 'Sharqia', 'Aswan',
    'Damietta', 'Beheira', 'Minya', 'Beni Suef', 'Qena',
    'Sohag', 'Red Sea', 'South Sinai', 'North Sinai', 'Matrouh'
  ];
  
  private subscriptions: Subscription[] = [];

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private propertyService: PropertyService,
    private amenitiesService: AmenitiesService,
    private authService: AuthService
  ) {}

  ngOnInit(): void {
    // Check authentication
    if (!this.authService.isLoggedIn()) {
      this.router.navigate(['/log-in']);
      return;
    }

    // Initialize form
    this.initializeForm();
    
    // Load amenities
    this.loadAmenities();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }

  initializeForm(): void {
    this.propertyForm = this.formBuilder.group({
      title: ['', [Validators.required, Validators.minLength(3)]],
      description: ['', [Validators.required, Validators.minLength(10)]],
      price: ['', [Validators.required, Validators.min(1)]],
      propertyType: ['', Validators.required],
      size: ['', [Validators.required, Validators.min(1)]],
      bedrooms: ['', [Validators.required, Validators.min(0)]],
      bathrooms: ['', [Validators.required, Validators.min(1)]],
      street: ['', Validators.required],
      city: ['', Validators.required],
      governate: ['', Validators.required],
      internalAmenitiesIds: this.formBuilder.array([]),
      externalAmenitiesIds: this.formBuilder.array([]),
      accessibilityAmenitiesIds: this.formBuilder.array([])
    });
  }

  loadAmenities(): void {
    this.isLoading = true;
    
    // Load internal amenities
    const internalSub = this.amenitiesService.getInternalAmenities().subscribe({
      next: (amenities) => {
        this.internalAmenities = amenities.filter(a => a.name !== 'string');
      },
      error: (error) => {
        console.error('Error loading internal amenities:', error);
      }
    });
    
    // Load external amenities
    const externalSub = this.amenitiesService.getExternalAmenities().subscribe({
      next: (amenities) => {
        this.externalAmenities = amenities.filter(a => a.name !== 'string');
      },
      error: (error) => {
        console.error('Error loading external amenities:', error);
      }
    });
    
    // Load accessibility amenities
    const accessibilitySub = this.amenitiesService.getAccessibilityAmenities().subscribe({
      next: (amenities) => {
        this.accessibilityAmenities = amenities.filter(a => a.name !== 'string');
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading accessibility amenities:', error);
        this.isLoading = false;
      }
    });
    
    this.subscriptions.push(internalSub, externalSub, accessibilitySub);
  }

  // Getter for form controls
  get f() { return this.propertyForm.controls; }
  
  // Get FormArray for amenities
  getAmenitiesFormArray(type: string): FormArray {
    return this.propertyForm.get(`${type}AmenitiesIds`) as FormArray;
  }

  // Handle amenity checkbox change
  onAmenityChange(event: any, amenityId: number, type: 'internal' | 'external' | 'accessibility'): void {
    const formArray = this.getAmenitiesFormArray(type);
    
    if (event.target.checked) {
      formArray.push(this.formBuilder.control(amenityId));
    } else {
      const index = formArray.controls.findIndex(control => control.value === amenityId);
      if (index !== -1) {
        formArray.removeAt(index);
      }
    }
  }

  // Handle image file selection
  onImageFilesSelected(event: any): void {
    const files = Array.from(event.target.files) as File[];
    
    if (files.length > 10) {
      Swal.fire({
        icon: 'warning',
        title: 'Too Many Images',
        text: 'You can upload maximum 10 images',
        confirmButtonColor: '#08227B'
      });
      return;
    }

    this.imageFiles = files;
    this.imagePreviews = [];

    // Generate previews
    files.forEach(file => {
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onload = (e: any) => {
          this.imagePreviews.push(e.target.result);
        };
        reader.readAsDataURL(file);
      }
    });
  }

  // Remove image preview
  removeImage(index: number): void {
    this.imageFiles.splice(index, 1);
    this.imagePreviews.splice(index, 1);
  }

  // Show payment modal
  showPayment(): void {
    if (this.propertyForm.invalid) {
      this.submitted = true;
      this.scrollToFirstError();
      return;
    }

    if (this.imageFiles.length === 0) {
      Swal.fire({
        icon: 'warning',
        title: 'Images Required',
        text: 'Please select at least one image for your property',
        confirmButtonColor: '#08227B'
      });
      return;
    }

    this.showPaymentModal = true;
  }

  // Handle payment success
  onPaymentSuccess(paymentData: any): void {
    this.paymentCompleted = true;
    this.paymentData = paymentData;
    this.showPaymentModal = false;
    
    // Now submit the property
    this.submitProperty();
  }

  // Handle payment cancellation
  onPaymentCancel(): void {
    this.showPaymentModal = false;
  }

  // Submit property after payment
  submitProperty(): void {
    this.isSubmitting = true;

    // Prepare form data
    const formData = new FormData();
    const formValues = this.propertyForm.value;

    // Add basic property data
    Object.keys(formValues).forEach(key => {
      if (key.includes('AmenitiesIds')) {
        // Handle amenities arrays
        const amenityIds = formValues[key];
        amenityIds.forEach((id: number, index: number) => {
          formData.append(`${key}[${index}]`, id.toString());
        });
      } else {
        formData.append(key, formValues[key]);
      }
    });

    // Add images
    this.imageFiles.forEach((file, index) => {
      formData.append(`images`, file);
    });

    // Add payment information
    if (this.paymentData) {
      formData.append('paymentIntentId', this.paymentData.paymentIntentId);
      formData.append('paymentAmount', this.paymentData.amount.toString());
    }

    // Submit to API
    const submitSub = this.propertyService.addProperty(formData).subscribe({
      next: (response) => {
        this.isSubmitting = false;
        Swal.fire({
          icon: 'success',
          title: 'Property Listed Successfully',
          text: 'Your property has been listed successfully and payment has been processed!',
          confirmButtonColor: '#08227B'
        }).then(() => {
          this.router.navigate(['/home']);
        });
      },
      error: (error) => {
        this.isSubmitting = false;
        console.error('Error adding property:', error);
        
        let errorMessage = 'Failed to add property. Please try again.';
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        }

        Swal.fire({
          icon: 'error',
          title: 'Error Adding Property',
          text: errorMessage,
          confirmButtonColor: '#08227B'
        });
      }
    });

    this.subscriptions.push(submitSub);
  }

  // Submit form (now opens payment modal)
  onSubmit(): void {
    this.showPayment();
  }

  // Scroll to first error
  scrollToFirstError(): void {
    const firstErrorField = Object.keys(this.propertyForm.controls).find(
      key => this.propertyForm.get(key)?.invalid
    );
    
    if (firstErrorField) {
      const element = document.getElementById(firstErrorField);
      if (element) {
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        element.focus();
      }
    }
  }

  // Go back to home
  goBack(): void {
    if (this.propertyForm.dirty) {
      Swal.fire({
        title: 'Discard Changes?',
        text: 'You have unsaved changes. Are you sure you want to leave?',
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#08227B',
        cancelButtonColor: '#d33',
        confirmButtonText: 'Yes, discard changes'
      }).then((result) => {
        if (result.isConfirmed) {
          this.router.navigate(['/home']);
        }
      });
    } else {
      this.router.navigate(['/home']);
    }
  }

  // Check if amenity is selected
  isAmenitySelected(amenityId: number, type: 'internal' | 'external' | 'accessibility'): boolean {
    const formArray = this.getAmenitiesFormArray(type);
    return formArray.controls.some(control => control.value === amenityId);
  }
}


================================================
File: app/chat-bot/chat-bot.component.css
================================================



================================================
File: app/chat-bot/chat-bot.component.html
================================================
<div class="container py-5">
    <div class="row">
      <div class="col-md-8 mx-auto">
        <div class="card shadow-sm border-0 rounded-4 overflow-hidden">
          <div class="card-header bg-primary text-white py-3">
            <div class="d-flex align-items-center">
              <img src="assets/images/chat-bot.png" alt="Chat Bot" class="bot-avatar me-3">
              <div>
                <h5 class="mb-0">X-Rental Assistant</h5>
                <small class="text-white-50">Online</small>
              </div>
              <button class="btn btn-sm btn-light ms-auto" (click)="goBack()">
                Back to Dashboard
              </button>
            </div>
          </div>
          
          <div class="card-body chat-container p-4">
            <div class="chat-messages" #chatMessages>
              <div *ngFor="let message of messages" class="message-wrapper" [ngClass]="{'user-message': message.isUser, 'bot-message': !message.isUser}">
                <div class="message">
                  <div class="message-content">{{ message.content }}</div>
                  <div class="message-time">{{ message.timestamp | date:'shortTime' }}</div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="card-footer bg-white border-top-0 p-3">
            <div class="input-group">
              <input 
                type="text" 
                class="form-control border-0 bg-light rounded-pill me-2" 
                placeholder="Type your message..." 
                [(ngModel)]="newMessage"
                (keyup.enter)="sendMessage()"
              >
              <button class="btn btn-primary rounded-pill" (click)="sendMessage()">
                <i class="bi bi-send-fill"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>


================================================
File: app/chat-bot/chat-bot.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ChatBotComponent } from './chat-bot.component';

describe('ChatBotComponent', () => {
  let component: ChatBotComponent;
  let fixture: ComponentFixture<ChatBotComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ChatBotComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(ChatBotComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/chat-bot/chat-bot.component.ts
================================================
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import Swal from 'sweetalert2';

interface ChatMessage {
  content: string;
  isUser: boolean;
  timestamp: Date;
}

@Component({
  selector: 'app-chat-bot',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './chat-bot.component.html',
  styleUrls: ['./chat-bot.component.css']
})
export class ChatBotComponent implements OnInit {
  messages: ChatMessage[] = [];
  newMessage: string = '';
  
  constructor(private router: Router) {}

  ngOnInit(): void {
    // Check if user is authenticated
    const token = localStorage.getItem('token');
    if (!token) {
      // User is not authenticated, redirect to login page
      Swal.fire({
        icon: 'warning',
        title: 'Authentication Required',
        text: 'Please log in to access this page',
        timer: 2000,
        showConfirmButton: false
      }).then(() => {
        this.router.navigate(['/log-in']);
      });
      return;
    }
    
    // Initial bot messages
    this.addBotMessage('Hello! I\'m your X-Rental assistant. How can I help you today?');
    this.addBotMessage('You can ask me about properties, rental process, or any other questions you have.');
  }

  sendMessage(): void {
    if (!this.newMessage.trim()) return;
    
    // Add user message
    this.messages.push({
      content: this.newMessage,
      isUser: true,
      timestamp: new Date()
    });
    
    const userQuery = this.newMessage.toLowerCase();
    this.newMessage = '';
    
    // Simulate bot response
    setTimeout(() => {
      let botResponse = '';
      
      if (userQuery.includes('property') || userQuery.includes('properties')) {
        botResponse = 'We have various properties available. You can browse them in the dashboard or use the search filters to find specific types.';
      } else if (userQuery.includes('rent') || userQuery.includes('rental')) {
        botResponse = 'Our rental process is simple: Find a property you like, schedule a visit, and if you decide to proceed, we\'ll help with the paperwork.';
      } else if (userQuery.includes('price') || userQuery.includes('cost')) {
        botResponse = 'Property prices vary depending on location, size, and features. You can see the price of each property on its card.';
      } else if (userQuery.includes('location') || userQuery.includes('area')) {
        botResponse = 'We have properties in various locations across Cairo, including El-Sherouk, Maadi, and other popular areas.';
      } else if (userQuery.includes('hi') || userQuery.includes('hello')) {
        botResponse = 'Hello there! How can I assist you with your property search today?';
      } else {
        botResponse = 'I\'m sorry, I\'m still learning. Could you ask me about our properties, rental process, or contact information?';
      }
      
      this.addBotMessage(botResponse);
    }, 1000);
  }
  
  addBotMessage(content: string): void {
    this.messages.push({
      content,
      isUser: false,
      timestamp: new Date()
    });
  }
  
  goBack(): void {
    this.router.navigate(['/dashboard']);
  }
}


================================================
File: app/favorites/favorites.component.css
================================================
.property-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }
  
  .property-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15) !important;
  }
  
  .property-img {
    height: 200px;
    object-fit: cover;
  }
  
  .property-details {
    border-top: 1px solid #eee;
    border-bottom: 1px solid #eee;
    padding: 10px 0;
  }
  
  .btn-primary {
    background-color: #08227B;
    border-color: #08227B;
  }
  
  .btn-primary:hover {
    background-color: #061a5f;
    border-color: #061a5f;
  }
  
  .text-primary {
    color: #08227B !important;
  }
  
  .badge.bg-primary {
    background-color: #08227B !important;
  }
  
  .btn-danger {
    background-color: #dc3545;
    border-color: #dc3545;
  }
  
  @media (max-width: 768px) {
    .property-card {
      margin-bottom: 1rem;
    }
    
    .property-details .row {
      text-align: center;
    }
  }



================================================
File: app/favorites/favorites.component.html
================================================
<div class="container py-5">
  <div class="card shadow-sm border-0 rounded-4 p-4 mb-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h2 class="text-primary mb-0">
        <i class="bi bi-heart-fill text-danger me-2"></i>
        Your Favorite Properties
      </h2>
      <button class="btn btn-outline-secondary" (click)="goToDashboard()">
        <i class="bi bi-arrow-left"></i> Back to Home
      </button>
    </div>
    
    <!-- Loading State -->
    <div *ngIf="isLoading" class="text-center py-5">
      <div class="spinner-border text-primary" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <p class="mt-3">Loading your favorites...</p>
    </div>
    
    <!-- No favorites -->
    <div *ngIf="!isLoading && favorites.length === 0" class="text-center py-5">
      <i class="bi bi-heart" style="font-size: 4rem; color: #ccc;"></i>
      <h4 class="mt-3">No favorites yet</h4>
      <p class="text-muted">Properties you mark as favorites will appear here</p>
      <button class="btn btn-primary mt-3" (click)="goToDashboard()">
        <i class="bi bi-search"></i> Browse Properties
      </button>
    </div>
    
    <!-- Favorites Grid -->
    <div *ngIf="!isLoading && favorites.length > 0" class="row g-4">
      <div class="col-lg-4 col-md-6" *ngFor="let property of favorites; trackBy: trackByPropertyId">
        <div class="card h-100 border-0 shadow-sm rounded-4 overflow-hidden property-card">
          <!-- Property Image -->
          <div class="position-relative">
            <img 
              [src]="getFirstImage(property)" 
              class="card-img-top property-img" 
              [alt]="property.title"
              (error)="onImageError($event)"
              loading="lazy"
            >
            <!-- Property Type Badge -->
            <span class="badge bg-primary position-absolute top-0 start-0 m-2">
              {{ property.propertyType }}
            </span>
            <!-- NO HEART ON IMAGE - removed -->
          </div>
          
          <!-- Property Info -->
          <div class="card-body d-flex flex-column">
            <div class="mb-3">
              <h5 class="card-title mb-2">{{ property.title }}</h5>
              <p class="text-muted mb-1 small">
                <i class="bi bi-geo-alt"></i> {{ property.street || property.city }}, {{ property.governate }}
              </p>
              <div class="d-flex justify-content-between align-items-center">
                <h5 class="text-primary mb-0">{{ formatPrice(property.price) }}</h5>
                <small class="text-muted">
                  Added {{ formatDate(property.listedAt) }}
                </small>
              </div>
            </div>
            
            <!-- Property Details -->
            <div class="property-details mb-3" *ngIf="property.size > 0 || property.bedrooms > 0 || property.bathrooms > 0">
              <div class="row text-center g-0">
                <div class="col" *ngIf="property.size > 0">
                  <p class="fw-bold mb-0 small">Size</p>
                  <p class="small text-muted">{{ property.size }} mÂ²</p>
                </div>
                <div class="col" *ngIf="property.bedrooms > 0">
                  <p class="fw-bold mb-0 small">Beds</p>
                  <p class="small text-muted">{{ property.bedrooms }}</p>
                </div>
                <div class="col" *ngIf="property.bathrooms > 0">
                  <p class="fw-bold mb-0 small">Baths</p>
                  <p class="small text-muted">{{ property.bathrooms }}</p>
                </div>
              </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="mt-auto d-flex gap-2">
              <button 
                class="btn btn-primary flex-grow-1" 
                (click)="viewProperty(property.propertyId)"
                [class.disabled]="isRemoving"
              >
                <i class="bi bi-eye"></i> View Details
              </button>
              <button 
                class="btn btn-danger" 
                (click)="removeFromFavorites(property.propertyId)"
                [class.disabled]="isRemoving"
                title="Remove from favorites"
              >
                <span *ngIf="!isRemoving">
                  <i class="bi bi-heart-fill"></i>
                </span>
                <span *ngIf="isRemoving">
                  <span class="spinner-border spinner-border-sm"></span>
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Summary -->
    <div *ngIf="!isLoading && favorites.length > 0" class="text-center mt-4 pt-3 border-top">
      <p class="text-muted">
        <i class="bi bi-info-circle"></i>
        You have {{ favorites.length }} favorite {{ favorites.length === 1 ? 'property' : 'properties' }}
      </p>
    </div>
  </div>
</div>

  


================================================
File: app/favorites/favorites.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { FavoritesComponent } from './favorites.component';

describe('FavoritesComponent', () => {
  let component: FavoritesComponent;
  let fixture: ComponentFixture<FavoritesComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [FavoritesComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(FavoritesComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/favorites/favorites.component.ts
================================================
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Router, RouterModule } from '@angular/router';
import { Subscription } from 'rxjs';
import { PropertyService, Property } from '../services/property.service';
import { AuthService } from '../services/auth.service';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-favorites',
  standalone: true,
  imports: [CommonModule, RouterModule],
  templateUrl: './favorites.component.html',
  styleUrls: ['./favorites.component.css']
})
export class FavoritesComponent implements OnInit, OnDestroy {
  favorites: Property[] = [];
  isLoading: boolean = true;
  isLoggedIn: boolean = false;
  isRemoving: boolean = false;
  
  private subscriptions: Subscription[] = [];
  
  constructor(
    private router: Router,
    private propertyService: PropertyService,
    private authService: AuthService
  ) {}

  ngOnInit(): void {
    this.isLoggedIn = this.authService.isLoggedIn();
    
    if (!this.isLoggedIn) {
      Swal.fire({
        icon: 'warning',
        title: 'Authentication Required',
        text: 'Please log in to access your favorites',
        timer: 2000,
        showConfirmButton: false
      }).then(() => {
        this.router.navigate(['/log-in']);
      });
      return;
    }
    
    this.loadFavorites();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }

  loadFavorites(): void {
    this.isLoading = true;
    console.log('🔍 Loading user favorites...');
    
    const favSub = this.propertyService.getFavorites().subscribe({
      next: (favorites) => {
        console.log('✅ Favorites loaded successfully:', favorites);
        this.favorites = favorites;
        this.isLoading = false;
      },
      error: (error) => {
        console.error('❌ Error loading favorites:', error);
        this.isLoading = false;
        
        Swal.fire({
          icon: 'error',
          title: 'Failed to Load Favorites',
          text: 'Unable to load your favorite properties. Please try again.',
          confirmButtonColor: '#08227B'
        });
      }
    });
    
    this.subscriptions.push(favSub);
  }

  viewProperty(propertyId: number): void {
    console.log('🔍 Navigating to property details:', propertyId);
    this.router.navigate(['/property', propertyId]);
  }
  
  removeFromFavorites(propertyId: number): void {
    if (this.isRemoving) return;
    
    console.log('🔍 Removing property from favorites:', propertyId);
    
    Swal.fire({
      title: 'Remove from favorites?',
      text: 'This property will be removed from your favorites',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#08227B',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Yes, remove it',
      cancelButtonText: 'Cancel'
    }).then((result) => {
      if (result.isConfirmed) {
        this.isRemoving = true;
        
        const removeSub = this.propertyService.removeFromFavorites(propertyId).subscribe({
          next: (response) => {
            console.log('✅ Property removed from favorites:', response);
            this.isRemoving = false;
            
            // Remove from local array immediately
            this.favorites = this.favorites.filter(property => property.propertyId !== propertyId);
            
            Swal.fire({
              position: 'top-end',
              icon: 'success',
              title: 'Removed from favorites',
              showConfirmButton: false,
              timer: 1500
            });
          },
          error: (error) => {
            console.error('❌ Error removing from favorites:', error);
            console.log('📊 Error details:', {
              status: error.status,
              statusText: error.statusText,
              message: error.message,
              error: error.error
            });
            
            this.isRemoving = false;
            
            // Check if it's actually a successful response that Angular is treating as error
            if (error.status === 200 || error.status === 0) {
              console.log('✅ Actually successful - removing from local array');
              
              // Remove from local array since the API call was actually successful
              this.favorites = this.favorites.filter(property => property.propertyId !== propertyId);
              
              Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'Removed from favorites',
                showConfirmButton: false,
                timer: 1500
              });
              return;
            }
            
            let errorMessage = 'Unable to remove property from favorites.';
            
            if (error.status === 404) {
              // Handle 404 - property not in favorites
              console.log('⚠️ Property not found in favorites (404), removing from local list anyway');
              
              // Remove from local array since it's not in server anyway
              this.favorites = this.favorites.filter(property => property.propertyId !== propertyId);
              
              Swal.fire({
                position: 'top-end',
                icon: 'info',
                title: 'Property was already removed',
                text: 'This property was not in your favorites',
                showConfirmButton: false,
                timer: 2000
              });
              return; // Exit early, don't show error
            } else if (error.status === 401) {
              errorMessage = 'You need to be logged in to remove favorites.';
            } else if (error.status === 500) {
              errorMessage = 'Server error. Please try again later.';
            }
            
            Swal.fire({
              icon: 'error',
              title: 'Failed to Remove',
              text: errorMessage,
              confirmButtonColor: '#08227B'
            });
          }
        });
        
        this.subscriptions.push(removeSub);
      }
    });
  }
  
  // MISSING METHODS - Added below:
  
  goToDashboard(): void {
    this.router.navigate(['/home']);
  }

  // Helper methods
  getFirstImage(property: Property): string {
    if (property.propertyImages && property.propertyImages.length > 0) {
      return property.propertyImages[0];
    }
    return 'assets/images/apartment.avif';
  }

  formatPrice(price: number): string {
    return new Intl.NumberFormat('en-EG', {
      style: 'currency',
      currency: 'EGP',
      minimumFractionDigits: 0
    }).format(price);
  }

  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('en-EG', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  }

  onImageError(event: any): void {
    event.target.src = 'assets/images/apartment.avif';
  }

  trackByPropertyId(index: number, property: Property): number {
    return property.propertyId;
  }

  // Additional helper methods
  refreshFavorites(): void {
    this.loadFavorites();
  }
}


================================================
File: app/filters/filters.component.css
================================================



================================================
File: app/filters/filters.component.html
================================================
<p>filters works!</p>



================================================
File: app/filters/filters.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { FiltersComponent } from './filters.component';

describe('FiltersComponent', () => {
  let component: FiltersComponent;
  let fixture: ComponentFixture<FiltersComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [FiltersComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(FiltersComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/filters/filters.component.ts
================================================
import { Component } from '@angular/core';

@Component({
  selector: 'app-filters',
  standalone: true,
  imports: [],
  templateUrl: './filters.component.html',
  styleUrl: './filters.component.css'
})
export class FiltersComponent {

}



================================================
File: app/forget-pass/forget-pass.component.css
================================================



================================================
File: app/forget-pass/forget-pass.component.html
================================================
<!-- Forgot Password Component HTML with loading states -->
<div class="container">
    <!-- Left side (Form inputs) -->
    <div class="form-side">
      <div class="form-container">
        <h1 class="title">Forget Password</h1>
        <p class="subtitle">Enter your Email to reset your password.</p>
  
        <!-- Progress steps -->
        <div class="steps-container">
          <div class="step active">
            <div class="step-number">1</div>
          </div>
          <div class="step-line"></div>
          <div class="step">
            <div class="step-number">2</div>
          </div>
          <div class="step-line"></div>
          <div class="step">
            <div class="step-number">3</div>
          </div>
        </div>
  
        <form (ngSubmit)="onSubmit()" [formGroup]="forgotPasswordForm">
          <!-- Email or Phone label -->
          <div class="input-label">
            <h3>Email Address</h3>
          </div>
  
          <!-- Email input -->
          <div class="form-group">
            <input 
              type="email" 
              formControlName="emailOrPhone" 
              placeholder="Enter your email address"
              class="form-control"
              [ngClass]="{'invalid': submitted && f['emailOrPhone'].errors}"
              [disabled]="isLoading"
            >
            <div *ngIf="submitted && f['emailOrPhone'].errors" class="error-message">
              <div *ngIf="f['emailOrPhone'].errors['required']">Email is required</div>
              <div *ngIf="f['emailOrPhone'].errors['invalidFormat']">Please enter a valid email address</div>
            </div>
          </div>
          
          <!-- Submit button -->
          <button type="submit" class="reset-btn" [disabled]="isLoading">
            <span *ngIf="!isLoading">Send Reset Code</span>
            <span *ngIf="isLoading">
              <i class="bi bi-arrow-clockwise animate-spin"></i>
              Sending...
            </span>
          </button>
        </form>

        <!-- Back to login link -->
        <div class="back-to-login" style="text-align: center; margin-top: 20px;">
          <span>Remember your password? </span>
          <a [routerLink]="['/log-in']" *ngIf="!isLoading" style="color: #0c2b7a; text-decoration: none; font-weight: bold;">Back to Login</a>
        </div>
      </div>
    </div>
  
    <!-- Right side (Blue background with image) -->
    <div class="image-side">
      <div class="close-button">
        <button class="close-btn" (click)="goHome()">
          <i class="bi bi-x"></i>
        </button>
      </div>
      <div class="image-container">
        <img src="../../assets/images/forgetpassword.png" alt="Forgot password illustration">
      </div>
    </div>
  </div>

  <!-- Add CSS for loading animation -->
  <style>
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    
    .reset-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .form-control:disabled {
      background-color: #f5f5f5;
      opacity: 0.6;
    }
  </style>


================================================
File: app/forget-pass/forget-pass.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ForgetPassComponent } from './forget-pass.component';

describe('ForgetPassComponent', () => {
  let component: ForgetPassComponent;
  let fixture: ComponentFixture<ForgetPassComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ForgetPassComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(ForgetPassComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/forget-pass/forget-pass.component.ts
================================================
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, AbstractControl, ValidationErrors } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-forget-pass',
  templateUrl: './forget-pass.component.html',
  styleUrls: ['./forget-pass.component.css'],
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule]
})
export class ForgetPassComponent implements OnInit {
  forgotPasswordForm!: FormGroup;
  submitted = false;
  isLoading = false;

  constructor(
    private formBuilder: FormBuilder,
    public router: Router
  ) { }

  ngOnInit(): void {
    this.forgotPasswordForm = this.formBuilder.group({
      emailOrPhone: ['', [Validators.required, this.validateEmailOrPhone]]
    });
  }

  validateEmailOrPhone(control: AbstractControl): ValidationErrors | null {
    const value = control.value;
    const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    const phonePattern = /^\+?\d{10,15}$/;

    if (!value) return null;
    if (emailPattern.test(value) || phonePattern.test(value)) return null;

    return { invalidFormat: true };
  }

  get f() { return this.forgotPasswordForm.controls; }

  onSubmit(): void {
    this.submitted = true;

    if (this.forgotPasswordForm.invalid) return;

    this.isLoading = true;
    setTimeout(() => {
      console.log('Form submitted', this.forgotPasswordForm.value);
      this.router.navigate(['/otp-verification'], {
        queryParams: { contact: this.forgotPasswordForm.value.emailOrPhone }
      });
      this.isLoading = false;
    }, 2000);
  }

  // ✅ أضفناها لحل الخطأ
  goHome(): void {
    this.router.navigate(['/home']);
  }
}



================================================
File: app/guards/auth.guard.ts
================================================
import { inject } from '@angular/core';
import { Router, CanActivateFn } from '@angular/router';
import { CookieService } from 'ngx-cookie-service';

export const authGuard: CanActivateFn = (route, state) => {
  const cookieService = inject(CookieService);
  const router = inject(Router);
  
  const token = cookieService.get('token');
  
  if (token) {
    return true;
  }
  
  // Show alert and redirect to login
  alert('Authentication Required. Please log in to access this page');
  router.navigate(['/log-in'], { queryParams: { returnUrl: state.url } });
  
  return false;
};


================================================
File: app/home/home.component.css
================================================



================================================
File: app/home/home.component.html
================================================
<!-- Alert Component -->
<div class="alert-container" *ngIf="showAlert">
  <div class="alert" [ngClass]="{
    'alert-success': alertType === 'success',
    'alert-error': alertType === 'error',
    'alert-info': alertType === 'info'
  }">
    {{ alertMessage }}
  </div>
</div>

<!-- Header/Navigation -->
<header class="py-3">
  <div class="container">
    <div class="d-flex justify-content-between align-items-center">
      <div class="logo">
        <h2 class="fw-bold">X-rental</h2>
      </div>
      <div class="nav-links">
        <ul class="list-unstyled d-flex gap-4 mb-0">
          <li>
            <a [routerLink]="isLoggedIn ? ['/add-property'] : null" 
               (click)="!isLoggedIn && showLoginAlert()" 
               class="text-decoration-none text-dark pointer">Add new property</a>
          </li>
          <li>
            <a [routerLink]="isLoggedIn ? ['/favorites'] : null" 
               (click)="!isLoggedIn && showLoginAlert()" 
               class="text-decoration-none text-dark pointer">Favorite</a>
          </li>
          <li><a href="#" class="text-decoration-none text-dark">about Us</a></li>
          <li>
            <a [routerLink]="isLoggedIn ? ['/chat-bot'] : null" 
               (click)="!isLoggedIn && showLoginAlert()" 
               class="text-decoration-none text-dark pointer">chat Bot</a>
          </li>
        </ul>
      </div>
      
      <!-- Show auth buttons for guests or user profile for logged in users -->
      <div *ngIf="!isLoggedIn" class="auth-buttons">
        <a [routerLink]="['/sign-up']" class="btn btn-outline-dark rounded-pill me-2">sign up</a>
        <a [routerLink]="['/log-in']" class="btn btn-primary rounded-pill">login</a>
      </div>
      
      <div *ngIf="isLoggedIn" class="user-profile d-flex align-items-center">
        <span class="me-2">Welcome, {{ userName }}</span>
        <div class="dropdown">
          <a href="#" class="dropdown-toggle text-decoration-none" id="profileDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            <img src="assets/images/profile.jpeg" alt="Profile" class="rounded-circle" width="40" height="40">
          </a>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="profileDropdown">
            <li><a class="dropdown-item" [routerLink]="['/profile']">My Profile</a></li>
            <li><a class="dropdown-item" [routerLink]="['/my-properties']">My Properties</a></li>
            <li><hr class="dropdown-divider"></li>
            <li><a class="dropdown-item pointer" (click)="logout()">Logout</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<!-- Hero Section with Search -->
<section class="hero-section position-relative">
  <div class="hero-image">
    <!-- Background image will be applied via CSS -->
  </div>
  <div class="container">
    <div class="search-container py-5">
      <div class="row justify-content-center">
        <div class="col-md-10">
          <div class="search-bar-container bg-white rounded-pill shadow mt-5 p-2">
            <div class="d-flex align-items-center">
              <!-- Property Type Filters -->
              <div class="property-filters d-flex me-auto ms-3">
                <button class="btn btn-sm me-2" [ngClass]="{'btn-primary': selectedFilter === 'All', 'btn-link text-dark': selectedFilter !== 'All'}" 
                        (click)="filterByType('All')">All</button>
                <button class="btn btn-sm me-2" [ngClass]="{'btn-primary': selectedFilter === 'Apartment', 'btn-link text-dark': selectedFilter !== 'Apartment'}" 
                        (click)="filterByType('Apartment')">Apartment</button>
                <button class="btn btn-sm me-2" [ngClass]="{'btn-primary': selectedFilter === 'House', 'btn-link text-dark': selectedFilter !== 'House'}" 
                        (click)="filterByType('House')">House</button>
                <button class="btn btn-sm me-2" [ngClass]="{'btn-primary': selectedFilter === 'Office', 'btn-link text-dark': selectedFilter !== 'Office'}" 
                        (click)="filterByType('Office')">Office</button>
                <button class="btn btn-sm me-2" [ngClass]="{'btn-primary': selectedFilter === 'Villa', 'btn-link text-dark': selectedFilter !== 'Villa'}" 
                        (click)="filterByType('Villa')">Villa</button>
              </div>
              
              <!-- Search Input -->
              <div class="search-input d-flex align-items-center">
                <input type="text" class="form-control form-control-sm border-0" placeholder="Search properties..." 
                       [(ngModel)]="searchQuery" (keyup.enter)="searchProperties()">
                <button class="btn btn-primary btn-sm rounded-pill ms-2" (click)="searchProperties()" [disabled]="isLoading">
                  <i class="bi bi-search"></i> Search
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- Property Listings -->
<section class="property-listings py-5">
  <div class="container">
    <!-- Loading State -->
    <div *ngIf="isLoading" class="text-center py-5">
      <div class="spinner-border text-primary" style="width: 3rem; height: 3rem;" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <p class="mt-3">Loading properties...</p>
    </div>

    <!-- Properties Grid -->
    <div *ngIf="!isLoading" class="row g-4 justify-content-center">
      <!-- No Properties Found -->
      <div *ngIf="filteredProperties.length === 0" class="col-12 text-center py-5">
        <i class="bi bi-house" style="font-size: 4rem; color: #ccc;"></i>
        <h3 class="mt-3">No Properties Found</h3>
        <p class="text-muted">Try adjusting your search criteria or browse all properties.</p>
        <button class="btn btn-primary" (click)="filterByType('All')">Show All Properties</button>
      </div>
<!-- Property Cards -->
      <div class="col-md-6 col-lg-4 mb-4" *ngFor="let property of filteredProperties; trackBy: trackByPropertyId">
        <div class="property-card border-0 shadow-sm">
          <div class="position-relative">
            <img 
              [src]="getFirstImage(property)" 
              class="property-img" 
              [alt]="property.title"
              (error)="onImageError($event)"
              loading="lazy"
            >
            <!-- Property Type Badge -->
            <span class="badge bg-primary position-absolute top-0 start-0 m-2">{{ property.propertyType }}</span>
            <!-- NO HEART HERE - removed from image -->
          </div>
          <div class="property-info p-3">
            <div class="d-flex justify-content-between align-items-center mb-2">
              <div>
                <h5 class="mb-1">{{ property.title }}</h5>
                <p class="text-muted mb-0 small">
                  <i class="bi bi-geo-alt"></i> {{ property.street }}, {{ property.city }}
                </p>
              </div>
              <div>
                <h5 class="text-end text-primary">{{ formatPrice(property.price) }}</h5>
              </div>
            </div>
            
            <div class="property-details mt-3">
              <div class="row text-center g-0">
                <div class="col">
                  <p class="fw-bold mb-0">Size</p>
                  <p class="small">{{ property.size }} mÂ²</p>
                </div>
                <div class="col">
                  <p class="fw-bold mb-0">Beds</p>
                  <p class="small">{{ property.bedrooms }}</p>
                </div>
                <div class="col">
                  <p class="fw-bold mb-0">Baths</p>
                  <p class="small">{{ property.bathrooms }}</p>
                </div>
              </div>
            </div>
            
            <!-- Action Buttons Row -->
            <div class="mt-3 d-flex gap-2">
              <button 
                class="btn btn-primary rounded-pill flex-grow-1" 
                (click)="viewProperty(property.propertyId)"
              >
                View Details
              </button>
              
              <!-- Heart Button - Bottom Right -->
              <button 
                class="btn rounded-pill heart-btn" 
                [ngClass]="{
                  'btn-outline-secondary': !property.isFavorite,
                  'btn-danger': property.isFavorite
                }"
                (click)="toggleFavorite(property.propertyId)"
                [title]="property.isFavorite ? 'Remove from favorites' : 'Add to favorites'"
              >
                <i class="bi" 
                   [ngClass]="{
                     'bi-heart': !property.isFavorite,
                     'bi-heart-fill': property.isFavorite
                   }">
                </i>
              </button>
            </div>
          </div>
        </div>
      </div>

    <!-- Pagination -->
    <div *ngIf="!isLoading && filteredProperties.length > 0 && totalPages > 1" class="d-flex justify-content-center mt-5">
      <nav aria-label="Properties pagination">
        <ul class="pagination">
          <li class="page-item" [class.disabled]="currentPage === 1">
            <button class="page-link" (click)="previousPage()" [disabled]="currentPage === 1">
              <i class="bi bi-chevron-left"></i>
            </button>
          </li>
          
          <li class="page-item" *ngIf="currentPage > 3">
            <button class="page-link" (click)="goToPage(1)">1</button>
          </li>
          
          <li class="page-item disabled" *ngIf="currentPage > 4">
            <span class="page-link">...</span>
          </li>
          
          <li class="page-item" *ngFor="let page of getPaginationArray()" [class.active]="page === currentPage">
            <button class="page-link" (click)="goToPage(page)">{{ page }}</button>
          </li>
          
          <li class="page-item disabled" *ngIf="currentPage < totalPages - 3">
            <span class="page-link">...</span>
          </li>
          
          <li class="page-item" *ngIf="currentPage < totalPages - 2">
            <button class="page-link" (click)="goToPage(totalPages)">{{ totalPages }}</button>
          </li>
          
          <li class="page-item" [class.disabled]="currentPage === totalPages">
            <button class="page-link" (click)="nextPage()" [disabled]="currentPage === totalPages">
              <i class="bi bi-chevron-right"></i>
            </button>
          </li>
        </ul>
      </nav>
    </div>

    <!-- Results Summary -->
    <div *ngIf="!isLoading && filteredProperties.length > 0" class="text-center mt-3">
      <p class="text-muted">
        Showing {{ ((currentPage - 1) * pageSize) + 1 }} - {{ Math.min(currentPage * pageSize, totalCount) }} 
        of {{ totalCount }} properties
      </p>
    </div>
  </div>


<!-- Additional CSS for pagination and improved styling -->
<!-- Additional CSS for heart button and property cards -->
<style>
  .pagination .page-link {
    color: #08227B;
    border-color: #08227B;
  }
  
  .pagination .page-item.active .page-link {
    background-color: #08227B;
    border-color: #08227B;
  }
  
  .pagination .page-link:hover {
    background-color: rgba(8, 34, 123, 0.1);
    border-color: #08227B;
  }
  
  .property-card {
    border-radius: 20px !important;
    overflow: hidden;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    height: 100%;
  }
  
  .property-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15) !important;
  }
  
  .property-img {
    height: 220px;
    width: 100%;
    object-fit: cover;
  }
  
  .property-info {
    padding: 1.5rem;
    display: flex;
    flex-direction: column;
    height: calc(100% - 220px);
  }
  
  .property-details {
    border-top: 1px solid #eee;
    border-bottom: 1px solid #eee;
    padding: 15px 0;
    margin: auto 0;
  }
  
  .btn-primary {
    background-color: #08227B;
    border-color: #08227B;
  }
  
  .btn-primary:hover {
    background-color: #061a5f;
    border-color: #061a5f;
  }
  
  .text-primary {
    color: #08227B !important;
  }
  
  /* Heart Button Styles */
  .heart-btn {
    min-width: 45px;
    height: 38px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    border-width: 1px;
  }
  
  .heart-btn:hover {
    transform: scale(1.1);
  }
  
  /* Not favorited state - gray outline */
  .heart-btn.btn-outline-secondary {
    color: #6c757d;
    border-color: #6c757d;
    background-color: transparent;
  }
  
  .heart-btn.btn-outline-secondary:hover {
    color: #dc3545;
    border-color: #dc3545;
    background-color: transparent;
  }
  
  .heart-btn.btn-outline-secondary:hover i {
    color: #dc3545;
  }
  
  /* Favorited state - red filled */
  .heart-btn.btn-danger {
    color: white;
    background-color: #dc3545;
    border-color: #dc3545;
  }
  
  .heart-btn.btn-danger:hover {
    background-color: #c82333;
    border-color: #bd2130;
  }
  
  /* Heart icon transitions */
  .heart-btn i {
    font-size: 16px;
    transition: all 0.3s ease;
  }
  
  .loading-shimmer {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
  }
  
  @keyframes shimmer {
    0% {
      background-position: -200% 0;
    }
    100% {
      background-position: 200% 0;
    }
  }
  
  @media (max-width: 768px) {
    .property-filters {
      overflow-x: auto;
      flex-wrap: nowrap;
      width: 100%;
      justify-content: flex-start;
      padding-bottom: 5px;
    }
    
    .search-bar-container {
      flex-direction: column;
    }
    
    .search-input {
      width: 100%;
      margin-top: 10px;
      padding: 0 15px;
    }
    
    .pagination {
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .property-card {
      margin-bottom: 1rem;
    }
    
    .heart-btn {
      min-width: 40px;
      height: 35px;
    }
  }
</style>


================================================
File: app/home/home.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { HomeComponent } from './home.component';

describe('HomeComponent', () => {
  let component: HomeComponent;
  let fixture: ComponentFixture<HomeComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [HomeComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(HomeComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/home/home.component.ts
================================================
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterModule, Router } from '@angular/router';
import { Subscription, forkJoin } from 'rxjs';
import { AuthService } from '../services/auth.service';
import { PropertyService, Property, PropertyFilters } from '../services/property.service';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-home',
  standalone: true,
  imports: [CommonModule, FormsModule, RouterModule],
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit, OnDestroy {
  properties: Property[] = [];
  filteredProperties: Property[] = [];
  selectedFilter: string = 'All';
  searchQuery: string = '';
  isLoggedIn: boolean = false;
  userName: string = 'Guest';
  showAlert: boolean = false;
  alertMessage: string = '';
  alertType: 'success' | 'error' | 'info' = 'info';
  isLoading: boolean = true;
  
  // Pagination
  currentPage: number = 1;
  pageSize: number = 12;
  totalCount: number = 0;
  totalPages: number = 0;
  
  private subscriptions: Subscription[] = [];
  
  constructor(
    private router: Router,
    private authService: AuthService,
    private propertyService: PropertyService
  ) { }

  ngOnInit(): void {
    // Subscribe to authentication state changes
    const authSub = this.authService.currentUser$.subscribe(user => {
      this.isLoggedIn = !!user;
      if (user) {
        this.userName = this.authService.getUserFullName();
      } else {
        this.userName = 'Guest';
        this.router.navigate(['/log-in']);
      }
    });
    this.subscriptions.push(authSub);

    // Check initial authentication state
    this.isLoggedIn = this.authService.isLoggedIn();
    if (!this.isLoggedIn) {
      this.router.navigate(['/log-in']);
      return;
    }

    this.userName = this.authService.getUserFullName();
    this.loadProperties();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }

  loadProperties(filters?: PropertyFilters): void {
    this.isLoading = true;
    
    const searchFilters: PropertyFilters = {
      pageIndex: this.currentPage,
      pageSize: this.pageSize,
      ...filters
    };

    console.log('Loading properties with filters:', searchFilters);

    const propertySub = this.propertyService.getProperties(searchFilters).subscribe({
      next: (response) => {
        console.log('Properties loaded successfully:', response);
        
        this.properties = response.data;
        this.filteredProperties = [...this.properties];
        
        this.totalCount = response.totalCount;
        this.totalPages = Math.ceil(this.totalCount / this.pageSize);
        
        this.isLoading = false;
        
        if (this.isLoggedIn && this.properties.length > 0) {
          this.loadUserFavorites();
        }
      },
      error: (error) => {
        console.error('Error loading properties:', error);
        this.isLoading = false;
        this.showAlertMessage('Failed to load properties. Please try again.', 'error');
      }
    });
    this.subscriptions.push(propertySub);
  }

  loadUserFavorites(): void {
    console.log('Loading user favorites...');
    
    const favoriteChecks = this.properties.map(property => 
      this.propertyService.isPropertyInFavorites(property.propertyId)
    );

    if (favoriteChecks.length === 0) {
      return;
    }

    const favSub = forkJoin(favoriteChecks).subscribe({
      next: (favoriteStatuses) => {
        console.log('Favorite statuses loaded:', favoriteStatuses);
        
        this.properties.forEach((property, index) => {
          property.isFavorite = favoriteStatuses[index] || false;
        });
        
        this.filteredProperties = [...this.properties];
        console.log('Properties updated with favorite status');
      },
      error: (error) => {
        console.error('Error loading favorites:', error);
      }
    });
    this.subscriptions.push(favSub);
  }

  showAlertMessage(message: string, type: 'success' | 'error' | 'info' = 'info'): void {
    this.alertMessage = message;
    this.alertType = type;
    this.showAlert = true;
    
    setTimeout(() => {
      this.showAlert = false;
    }, 3000);
  }

  filterByType(type: string): void {
    this.selectedFilter = type;
    this.currentPage = 1;
    
    const filters: PropertyFilters = {};
    if (type !== 'All') {
      filters.propertyType = type;
    }
    
    this.loadProperties(filters);
  }

  searchProperties(): void {
    if (!this.searchQuery.trim()) {
      this.filterByType(this.selectedFilter);
      return;
    }
    
    this.currentPage = 1;
    const filters: PropertyFilters = {
      searchTerm: this.searchQuery.trim()
    };
    
    if (this.selectedFilter !== 'All') {
      filters.propertyType = this.selectedFilter;
    }
    
    this.loadProperties(filters);
  }

  toggleFavorite(propertyId: number): void {
    if (!this.isLoggedIn) {
      this.showAlertMessage('You need to login to add favorites', 'info');
      return;
    }
    
    const property = this.properties.find(p => p.propertyId === propertyId);
    if (!property) return;

    console.log('🔍 Toggling favorite for property:', propertyId, 'Current status:', property.isFavorite);

    // Store original state in case we need to revert
    const originalState = property.isFavorite;
    
    // Optimistically update UI immediately
    property.isFavorite = !property.isFavorite;
    
    // Update the filtered properties as well
    const filteredProperty = this.filteredProperties.find(p => p.propertyId === propertyId);
    if (filteredProperty) {
      filteredProperty.isFavorite = property.isFavorite;
    }

    // Force Angular change detection immediately
    setTimeout(() => {
      // This ensures the UI updates immediately
    }, 0);

    const action = property.isFavorite ? 'add' : 'remove';
    const apiCall = property.isFavorite 
      ? this.propertyService.addToFavorites(propertyId)
      : this.propertyService.removeFromFavorites(propertyId);

    const favSub = apiCall.subscribe({
      next: (response) => {
        console.log(`✅ ${action} favorite successful:`, response);
        
        const message = property.isFavorite ? 'Added to favorites' : 'Removed from favorites';
        this.showAlertMessage(message, 'success');
        
        // Ensure UI is up to date by triggering change detection
        this.properties = [...this.properties];
        this.filteredProperties = [...this.filteredProperties];
      },
      error: (error) => {
        console.error('❌ Error updating favorites:', error);
        
        // Handle 404 error gracefully for remove operations
        if (error.status === 404 && !property.isFavorite) {
          console.log('⚠️ Property was not in favorites (404), but UI updated correctly');
          this.showAlertMessage('Property removed from favorites', 'success');
          return;
        }
        
        // Revert the optimistic update on other errors
        property.isFavorite = originalState;
        if (filteredProperty) {
          filteredProperty.isFavorite = originalState;
        }
        
        // Force change detection
        this.properties = [...this.properties];
        this.filteredProperties = [...this.filteredProperties];
        
        let errorMessage = 'Failed to update favorites. Please try again.';
        if (error.status === 401) {
          errorMessage = 'You need to be logged in to manage favorites.';
        } else if (error.status === 500) {
          errorMessage = 'Server error. Please try again later.';
        }
        
        this.showAlertMessage(errorMessage, 'error');
      }
    });
    this.subscriptions.push(favSub);
  }
  
  viewProperty(propertyId: number): void {
    this.router.navigate(['/property', propertyId]);
  }
  
  showLoginAlert(): void {
    this.showAlertMessage('You need to login to access this feature', 'info');
  }
  
  logout(): void {
    Swal.fire({
      title: 'Are you sure?',
      text: 'You will be logged out of your account.',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#08227B',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Yes, logout'
    }).then((result) => {
      if (result.isConfirmed) {
        this.authService.logout();
        this.showAlertMessage('You have been successfully logged out', 'success');
        this.router.navigate(['/log-in']);
      }
    });
  }

  // Pagination methods
  goToPage(page: number): void {
    if (page >= 1 && page <= this.totalPages && page !== this.currentPage) {
      this.currentPage = page;
      this.loadProperties();
    }
  }

  previousPage(): void {
    if (this.currentPage > 1) {
      this.goToPage(this.currentPage - 1);
    }
  }

  nextPage(): void {
    if (this.currentPage < this.totalPages) {
      this.goToPage(this.currentPage + 1);
    }
  }

  // Helper methods
  getFirstImage(property: Property): string {
    if (property.propertyImages && property.propertyImages.length > 0) {
      return property.propertyImages[0];
    }
    return 'assets/images/apartment.avif';
  }

  formatPrice(price: number): string {
    return new Intl.NumberFormat('en-EG', {
      style: 'currency',
      currency: 'EGP',
      minimumFractionDigits: 0
    }).format(price);
  }

  getPaginationArray(): number[] {
    const pages: number[] = [];
    const start = Math.max(1, this.currentPage - 2);
    const end = Math.min(this.totalPages, this.currentPage + 2);
    
    for (let i = start; i <= end; i++) {
      pages.push(i);
    }
    
    return pages;
  }

  trackByPropertyId(index: number, property: Property): number {
    return property.propertyId;
  }

  Math = Math;

  getUserImageUrl(): string {
    return this.authService.getUserImageUrl();
  }

  onImageError(event: any): void {
    event.target.src = 'assets/images/apartment.avif';
  }

  // Additional utility methods
  refreshProperties(): void {
    this.currentPage = 1;
    this.loadProperties();
  }

  goToAddProperty(): void {
    this.router.navigate(['/add-property']);
  }

  goToFavorites(): void {
    this.router.navigate(['/favorites']);
  }

  goToChatBot(): void {
    this.router.navigate(['/chat-bot']);
  }

  getShortenedDescription(description: string, maxLength: number = 100): string {
    if (!description) return 'No description available';
    return description.length > maxLength 
      ? description.substring(0, maxLength) + '...' 
      : description;
  }

  formatListingDate(dateString: string): string {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - date.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    
    if (diffDays === 1) {
      return 'Listed today';
    } else if (diffDays <= 7) {
      return `Listed ${diffDays} days ago`;
    } else {
      return `Listed on ${date.toLocaleDateString('en-EG')}`;
    }
  }

  isNewProperty(dateString: string): boolean {
    const date = new Date(dateString);
    const now = new Date();
    const diffTime = Math.abs(now.getTime() - date.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays <= 7;
  }

  getPropertyStatusBadge(property: Property): string {
    if (this.isNewProperty(property.listedAt)) {
      return 'NEW';
    }
    if (property.isFavorite) {
      return 'FAVORITE';
    }
    return '';
  }

  getPropertyStatusBadgeClass(property: Property): string {
    if (this.isNewProperty(property.listedAt)) {
      return 'badge bg-success';
    }
    if (property.isFavorite) {
      return 'badge bg-danger';
    }
    return 'badge bg-secondary';
  }
}


================================================
File: app/interceptors/auth.interceptor.ts
================================================
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { CookieService } from 'ngx-cookie-service';

export const authInterceptor: HttpInterceptorFn = (req, next) => {
  const cookieService = inject<CookieService>(CookieService);
  const token = cookieService.get('token');
  
  // Clone the request and add the authentication header if token exists
  if (token) {
    const authReq = req.clone({
      headers: req.headers.set('Authorization', `Bearer ${token}`)
    });
    return next(authReq);
  }
  
  return next(req);
};


================================================
File: app/log-in/log-in.component.css
================================================



================================================
File: app/log-in/log-in.component.html
================================================
<!-- Login Component HTML with loading states -->
<div class="container">
    <!-- Left side (Blue background with image) -->
    <div class="image-side">
      <div class="close-button">
        <button class="close-btn" (click)="router.navigate(['/home'])">âœ•</button>
      </div>
      <div class="image-container">
        <img src="../../assets/images/login.png"  loading="lazy" width="400" height="250" alt="Property">
      </div>
    </div>
  
    <!-- Right side (Form inputs) -->
    <div class="form-side">
      <div class="form-container">
        <h1 class="title">Login here</h1>
        <p class="subtitle">Welcome back you've been missed!</p>
  
        <form (ngSubmit)="onSubmit()" [formGroup]="loginForm">
          <!-- Email input -->
          <div class="form-group">
            <input 
              type="email" 
              formControlName="email" 
              placeholder="Email"
              class="form-control"
              [ngClass]="{'invalid': submitted && f['email'].errors}"
              [disabled]="isLoading"
            >
            <div *ngIf="submitted && f['email'].errors" class="error-message">
              <div *ngIf="f['email'].errors['required']">Email is required</div>
              <div *ngIf="f['email'].errors['email']">Enter a valid email</div>
            </div>
          </div>
  
          <!-- Password input -->
          <div class="form-group">
            <div class="password-input">
              <input 
                [type]="showPassword ? 'text' : 'password'" 
                formControlName="password" 
                placeholder="Password"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['password'].errors}"
                [disabled]="isLoading"
              >
              <div class="toggle-password" (click)="togglePasswordVisibility()" *ngIf="!isLoading">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path *ngIf="!showPassword" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                  <path *ngIf="showPassword" d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                  <circle *ngIf="!showPassword" cx="12" cy="12" r="3"></circle>
                  <line *ngIf="showPassword" x1="1" y1="1" x2="23" y2="23"></line>
                </svg>
              </div>
            </div>
            <div *ngIf="submitted && f['password'].errors" class="error-message">
              <div *ngIf="f['password'].errors['required']">Password is required</div>
            </div>
          </div>
  
          <!-- Forgot password link -->
          <div class="forgot-password">
            <a [routerLink]="['/forget-pass']" *ngIf="!isLoading">Forgot your password?</a>
          </div>
  
          <!-- Login button -->
          <button type="submit" class="login-btn" [disabled]="isLoading">
            <span *ngIf="!isLoading">Sign in</span>
            <span *ngIf="isLoading">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin">
                <line x1="12" y1="2" x2="12" y2="6"></line>
                <line x1="12" y1="18" x2="12" y2="22"></line>
                <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
                <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
                <line x1="2" y1="12" x2="6" y2="12"></line>
                <line x1="18" y1="12" x2="22" y2="12"></line>
                <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
                <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
              </svg>
              Signing in...
            </span>
          </button>
        </form>
  
        <!-- Google login -->
        <div class="google-login">
          <button class="google-btn" (click)="loginWithGoogle()" [disabled]="isLoading">
            <img src="../../assets/images/google.png" alt="Google">
            Sign in with Google
          </button>
        </div>
  
        <!-- Sign up link -->
        <div class="signup-link">
          <span>Don't have an account?</span>
          <a [routerLink]="['/sign-up']" *ngIf="!isLoading">Sign up</a>
        </div>
      </div>
    </div>
  </div>
   <style>
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    
    .login-btn:disabled,
    .google-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .form-control:disabled {
      background-color: #f5f5f5;
      opacity: 0.6;
    }
  </style>


================================================
File: app/log-in/log-in.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { LogInComponent } from './log-in.component';

describe('LogInComponent', () => {
  let component: LogInComponent;
  let fixture: ComponentFixture<LogInComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [LogInComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(LogInComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/log-in/log-in.component.ts
================================================
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import Swal from 'sweetalert2';
import { AuthService, LoginRequest } from '../services/auth.service';

@Component({
  selector: 'app-log-in',
  templateUrl: './log-in.component.html',
  styleUrls: ['./log-in.component.css'],
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule]
})
export class LogInComponent implements OnInit {
  loginForm!: FormGroup;
  submitted = false;
  showPassword = false;
  isLoading = false;

  constructor(
    private formBuilder: FormBuilder,
    public router: Router,
    private authService: AuthService
  ) { }

  ngOnInit(): void {
    // Check if user is already logged in
    if (this.authService.isLoggedIn()) {
      // User is already logged in, redirect to home
      this.router.navigate(['/home']);
      return;
    }
    
    this.loginForm = this.formBuilder.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', Validators.required]
    });
  }

  // Getter for easy access to form fields
  get f() { return this.loginForm.controls; }

  onSubmit(): void {
    this.submitted = true;

    // Stop if form is invalid
    if (this.loginForm.invalid) {
      return;
    }

    this.isLoading = true;

    // Prepare login request
    const loginRequest: LoginRequest = {
      email: this.loginForm.value.email,
      password: this.loginForm.value.password
    };

    // Call the login API
    this.authService.login(loginRequest).subscribe({
      next: (response) => {
        this.isLoading = false;
        
        // Show success message
        Swal.fire({
          icon: 'success',
          title: 'Login Successful',
          text: 'Welcome back!',
          showConfirmButton: false,
          timer: 1500
        }).then(() => {
          // Navigate to home page after successful login
          this.router.navigate(['/home']);
        });
      },
      error: (error) => {
        this.isLoading = false;
        console.error('Login error:', error);
        
        // Handle different types of errors
        let errorMessage = 'Login failed. Please try again.';
        
        if (error.status === 400) {
          errorMessage = 'Invalid email or password.';
        } else if (error.status === 401) {
          errorMessage = 'Invalid credentials. Please check your email and password.';
        } else if (error.status === 0) {
          errorMessage = 'Unable to connect to server. Please check your internet connection.';
        } else if (error.error && error.error.message) {
          errorMessage = error.error.message;
        }

        Swal.fire({
          icon: 'error',
          title: 'Login Failed',
          text: errorMessage,
          confirmButtonColor: '#08227B'
        });
      }
    });
  }

  togglePasswordVisibility(): void {
    this.showPassword = !this.showPassword;
  }

  loginWithGoogle(): void {
    // Google login implementation will be added later
    Swal.fire({
      icon: 'info',
      title: 'Coming Soon',
      text: 'Google login will be available in a future update.',
      confirmButtonColor: '#08227B'
    });
  }
}


================================================
File: app/models/property.model.ts
================================================



================================================
File: app/models/user.model.ts
================================================



================================================
File: app/otp-verification/otp-verification.component.css
================================================



================================================
File: app/otp-verification/otp-verification.component.html
================================================
<div class="container">
    <!-- Right side (Blue background with image) -->
    <div class="image-side">
      <div class="close-button">
        <button class="close-btn">âœ•</button>
      </div>
      <div class="image-container">
        <img src="../../assets/images/otp.png" alt="OTP verification illustration">
      </div>
    </div>
  
    <!-- Left side (Form inputs) -->
    <div class="form-side">
      <div class="form-container">
        <h1 class="title">Enter OTP</h1>
        <p class="subtitle">Enter the OTP code we just sent<br>you on your registered Email/Phone number</p>
  
        <!-- Progress steps -->
        <div class="steps-container">
          <div class="step completed">
            <div class="step-number">1</div>
          </div>
          <div class="step-line completed"></div>
          <div class="step active">
            <div class="step-number">2</div>
          </div>
          <div class="step-line"></div>
          <div class="step">
            <div class="step-number">3</div>
          </div>
        </div>
  
        <form (ngSubmit)="onSubmit()" [formGroup]="otpForm">
          <!-- OTP input - Updated to 6 digits -->
          <div class="otp-container">
            <input 
              type="text" 
              maxlength="1" 
              formControlName="digit1" 
              class="otp-input"
              (keyup)="moveToNext($event, 2)"
              #digit1
            >
            <input 
              type="text" 
              maxlength="1" 
              formControlName="digit2" 
              class="otp-input"
              (keyup)="moveToNext($event, 3)"
              #digit2
            >
            <input 
              type="text" 
              maxlength="1" 
              formControlName="digit3" 
              class="otp-input"
              (keyup)="moveToNext($event, 4)"
              #digit3
            >
            <input 
              type="text" 
              maxlength="1" 
              formControlName="digit4" 
              class="otp-input"
              (keyup)="moveToNext($event, 5)"
              #digit4
            >
            <input 
              type="text" 
              maxlength="1" 
              formControlName="digit5" 
              class="otp-input"
              (keyup)="moveToNext($event, 6)"
              #digit5
            >
            <input 
              type="text" 
              maxlength="1" 
              formControlName="digit6" 
              class="otp-input"
              (keyup)="moveToNext($event, 0)"
              #digit6
            >
          </div>
          
          <div *ngIf="otpError" class="error-message text-center">
            {{ otpError }}
          </div>
          
          <!-- Submit button -->
          <button type="submit" class="reset-btn" [disabled]="!isOtpComplete()">Reset Password</button>
        </form>
  
        <!-- Resend OTP link -->
        <div class="resend-container">
          <span>Didn't get OTP? </span>
          <button type="button" class="resend-btn" [disabled]="countdown > 0" (click)="resendOtp()">
            {{ countdown > 0 ? 'Resend OTP in ' + countdown + 's' : 'Resend OTP' }}
          </button>
        </div>
      </div>
    </div>
  </div>


================================================
File: app/otp-verification/otp-verification.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { OtpVerificationComponent } from './otp-verification.component';

describe('OtpVerificationComponent', () => {
  let component: OtpVerificationComponent;
  let fixture: ComponentFixture<OtpVerificationComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [OtpVerificationComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(OtpVerificationComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/otp-verification/otp-verification.component.ts
================================================
import { Component, OnInit, OnDestroy, ViewChild, ElementRef } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { Router, ActivatedRoute, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import { interval, Subscription } from 'rxjs';
import { take } from 'rxjs/operators';
import Swal from 'sweetalert2';
import { AuthService, VerifyOtpRequest, ResendOtpRequest, ResendEmailConfirmationOtpRequest } from '../services/auth.service';

@Component({
  selector: 'app-otp-verification',
  templateUrl: './otp-verification.component.html',
  styleUrls: ['./otp-verification.component.css'],
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule]
})
export class OtpVerificationComponent implements OnInit, OnDestroy {
  @ViewChild('digit1') digit1!: ElementRef;
  @ViewChild('digit2') digit2!: ElementRef;
  @ViewChild('digit3') digit3!: ElementRef;
  @ViewChild('digit4') digit4!: ElementRef;
  @ViewChild('digit5') digit5!: ElementRef;
  @ViewChild('digit6') digit6!: ElementRef;
  
  otpForm!: FormGroup;
  email: string = '';
  otpType: string = ''; // 'signup' or 'forgot-password'
  otpError: string = '';
  countdown: number = 60;
  isLoading: boolean = false;
  isResending: boolean = false;
  countdownSubscription?: Subscription;

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private route: ActivatedRoute,
    private authService: AuthService
  ) { }

  ngOnInit(): void {
    // Initialize form with 6 digits
    this.otpForm = this.formBuilder.group({
      digit1: ['', [Validators.required, Validators.pattern('^[0-9]$')]],
      digit2: ['', [Validators.required, Validators.pattern('^[0-9]$')]],
      digit3: ['', [Validators.required, Validators.pattern('^[0-9]$')]],
      digit4: ['', [Validators.required, Validators.pattern('^[0-9]$')]],
      digit5: ['', [Validators.required, Validators.pattern('^[0-9]$')]],
      digit6: ['', [Validators.required, Validators.pattern('^[0-9]$')]]
    });

    // Get email and type from route parameters
    this.route.queryParams.subscribe(params => {
      this.email = params['contact'] || params['email'] || '';
      this.otpType = params['type'] || 'forgot-password'; // default to forgot-password
      
      if (!this.email) {
        // No email provided, redirect based on type
        if (this.otpType === 'signup') {
          this.router.navigate(['/sign-up']);
        } else {
          this.router.navigate(['/forget-pass']);
        }
      }
    });

    this.startCountdown();
  }

  ngAfterViewInit() {
    setTimeout(() => {
      if (this.digit1) {
        this.digit1.nativeElement.focus();
      }
    }, 0);
  }

  ngOnDestroy() {
    if (this.countdownSubscription) {
      this.countdownSubscription.unsubscribe();
    }
  }

  startCountdown() {
    this.countdown = 60;
    if (this.countdownSubscription) {
      this.countdownSubscription.unsubscribe();
    }
    
    this.countdownSubscription = interval(1000)
      .pipe(take(60))
      .subscribe(() => {
        this.countdown--;
        if (this.countdown === 0) {
          if (this.countdownSubscription) {
            this.countdownSubscription.unsubscribe();
          }
        }
      });
  }

  moveToNext(event: any, nextIndex: number) {
    const input = event.target;
    const value = input.value;
    
    if (value.length === 1) {
      // Move focus to the next input
      if (nextIndex > 0 && nextIndex <= 6) {
        const nextInput = this.getDigitElementByIndex(nextIndex);
        if (nextInput) {
          nextInput.nativeElement.focus();
        }
      }
    } else if (value.length === 0 && event.key === 'Backspace') {
      // Move focus to the previous input on backspace
      const prevIndex = nextIndex - 2;
      if (prevIndex >= 1 && prevIndex <= 6) {
        const prevInput = this.getDigitElementByIndex(prevIndex);
        if (prevInput) {
          prevInput.nativeElement.focus();
        }
      }
    }
    
    // Clear any previous errors
    this.otpError = '';
  }
  
  getDigitElementByIndex(index: number): ElementRef | null {
    switch (index) {
      case 1: return this.digit1;
      case 2: return this.digit2;
      case 3: return this.digit3;
      case 4: return this.digit4;
      case 5: return this.digit5;
      case 6: return this.digit6;
      default: return null;
    }
  }

  isOtpComplete(): boolean {
    const { digit1, digit2, digit3, digit4, digit5, digit6 } = this.otpForm.value;
    return !!digit1 && !!digit2 && !!digit3 && !!digit4 && !!digit5 && !!digit6;
  }

  resendOtp() {
    if (this.countdown === 0 && !this.isResending) {
      this.isResending = true;
      
      // Use the correct resend endpoint based on OTP type
      const resendObservable = this.otpType === 'signup' 
        ? this.authService.resendEmailConfirmationOtp({ email: this.email } as ResendEmailConfirmationOtpRequest)
        : this.authService.resendOtp({ email: this.email } as ResendOtpRequest);

      resendObservable.subscribe({
        next: (response) => {
          this.isResending = false;
          this.startCountdown();
          Swal.fire({
            icon: 'success',
            title: 'OTP Resent',
            text: 'A new OTP has been sent to your email.',
            showConfirmButton: false,
            timer: 2000
          });
        },
        error: (error) => {
          this.isResending = false;
          console.error('Resend OTP error:', error);
          Swal.fire({
            icon: 'error',
            title: 'Resend Failed',
            text: 'Failed to resend OTP. Please try again.',
            confirmButtonColor: '#08227B'
          });
        }
      });
    }
  }

  onSubmit(): void {
    if (this.otpForm.invalid || !this.isOtpComplete()) {
      this.otpError = 'Please enter all 6 digits';
      return;
    }

    this.isLoading = true;
    this.otpError = '';

    const { digit1, digit2, digit3, digit4, digit5, digit6 } = this.otpForm.value;
    const otp = `${digit1}${digit2}${digit3}${digit4}${digit5}${digit6}`;
    
    // Prepare verify OTP request
    const verifyRequest: VerifyOtpRequest = {
      email: this.email,
      otp: otp
    };

    // Call verify OTP API
    this.authService.verifyOtp(verifyRequest).subscribe({
      next: (response) => {
        this.isLoading = false;
        
        if (response.status === 'Success') {
          if (this.otpType === 'signup') {
            // For signup verification
            Swal.fire({
              icon: 'success',
              title: 'Account Verified',
              text: 'Your account has been verified successfully! You can now log in.',
              confirmButtonColor: '#08227B'
            }).then(() => {
              // Navigate to login page
              this.router.navigate(['/log-in']);
            });
          } else {
            // For password reset verification
            Swal.fire({
              icon: 'success',
              title: 'OTP Verified',
              text: 'OTP verified successfully! You can now reset your password.',
              confirmButtonColor: '#08227B'
            }).then(() => {
              // Navigate to reset password page
              this.router.navigate(['/reset-password'], { 
                queryParams: { email: this.email, verified: 'true' } 
              });
            });
          }
        } else {
          this.otpError = response.message || 'Invalid OTP. Please try again.';
        }
      },
      error: (error) => {
        this.isLoading = false;
        console.error('Verify OTP error:', error);
        
        let errorMessage = 'Invalid OTP. Please try again.';
        if (error.message) {
          errorMessage = error.message;
        } else if (error.status === 400) {
          errorMessage = 'Invalid OTP format or expired OTP.';
        }
        
        this.otpError = errorMessage;
      }
    });
  }

  // Clear form and start over
  clearForm(): void {
    this.otpForm.reset();
    this.otpError = '';
    if (this.digit1) {
      this.digit1.nativeElement.focus();
    }
  }

  // Go back to previous page
  goBack(): void {
    if (this.otpType === 'signup') {
      this.router.navigate(['/sign-up']);
    } else {
      this.router.navigate(['/forget-pass']);
    }
  }

  // Get page title based on type
  getPageTitle(): string {
    return this.otpType === 'signup' ? 'Verify Your Account' : 'Enter OTP';
  }

  // Get page subtitle based on type
  getPageSubtitle(): string {
    if (this.otpType === 'signup') {
      return 'Enter the 6-digit verification code we sent to your email to activate your account';
    } else {
      return 'Enter the 6-digit OTP code we just sent you on your registered Email/Phone number';
    }
  }
}


================================================
File: app/payment/payment.component.css
================================================
.payment-container {
  max-width: 500px;
  margin: 0 auto;
  padding: 30px;
  background: white;
  border-radius: 15px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}

.payment-header {
  text-align: center;
  margin-bottom: 30px;
}

.payment-header h4 {
  color: #08227B;
  margin-bottom: 8px;
  font-weight: 600;
}

.payment-amount {
  margin-bottom: 25px;
}

.amount-card {
  background: #f8f9fa;
  padding: 20px;
  border-radius: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 2px solid #e9ecef;
}

.amount-label {
  font-weight: 500;
  color: #495057;
}

.amount-value {
  font-size: 24px;
  font-weight: bold;
  color: #28a745;
}

.card-section {
  margin-bottom: 25px;
}

.card-section label {
  display: block;
  margin-bottom: 10px;
  font-weight: 600;
  color: #333;
}

.stripe-card {
  padding: 15px;
  border: 2px solid #e1e5e9;
  border-radius: 8px;
  background: white;
  transition: border-color 0.3s ease;
  min-height: 50px;
}

.stripe-card:focus-within {
  border-color: #08227B;
  box-shadow: 0 0 0 3px rgba(8, 34, 123, 0.1);
}

.error-message {
  color: #dc3545;
  font-size: 14px;
  margin-top: 10px;
  min-height: 20px;
}

.payment-actions {
  display: flex;
  gap: 15px;
  margin-bottom: 20px;
}

.btn {
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  min-height: 48px;
}

.btn-secondary {
  background: #6c757d;
  color: white;
  flex: 1;
}

.btn-secondary:hover:not(:disabled) {
  background: #5a6268;
}

.btn-primary {
  background: #08227B;
  color: white;
  flex: 2;
}

.btn-primary:hover:not(:disabled) {
  background: #061a5f;
}

.btn:disabled {
  background: #e9ecef;
  color: #6c757d;
  cursor: not-allowed;
}

.security-notice {
  text-align: center;
  padding: 15px;
  background: #d4edda;
  border: 1px solid #c3e6cb;
  border-radius: 8px;
  color: #155724;
  font-size: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.debug-info {
  border: 1px solid #ddd;
  font-family: monospace;
  background: #f8f9fa;
}

/* Stripe Elements Styling */
#card-element {
  padding: 15px;
}

.StripeElement {
  height: 40px;
  padding: 10px 12px;
  background-color: white;
  border: 1px solid transparent;
  border-radius: 4px;
}

.StripeElement--focus {
  border-color: #08227B;
  box-shadow: 0 0 0 3px rgba(8, 34, 123, 0.1);
}

.StripeElement--invalid {
  border-color: #dc3545;
}

.StripeElement--complete {
  border-color: #28a745;
}

/* Form Controls */
.form-control {
  display: block;
  width: 100%;
  padding: 0.375rem 0.75rem;
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5;
  color: #212529;
  background-color: #fff;
  background-image: none;
  border: 1px solid #ced4da;
  border-radius: 0.25rem;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}

.form-control:focus {
  color: #212529;
  background-color: #fff;
  border-color: #08227B;
  outline: 0;
  box-shadow: 0 0 0 0.2rem rgba(8, 34, 123, 0.25);
}

/* Debug Buttons */
.btn-sm {
  padding: 0.25rem 0.5rem;
  font-size: 0.875rem;
  border-radius: 0.2rem;
}

.btn-warning {
  color: #212529;
  background-color: #ffc107;
  border-color: #ffc107;
}

.btn-warning:hover {
  background-color: #ffca2c;
  border-color: #ffc720;
}

.btn-info {
  color: #fff;
  background-color: #17a2b8;
  border-color: #17a2b8;
}

.btn-info:hover {
  background-color: #138496;
  border-color: #117a8b;
}

/* Responsive Design */
@media (max-width: 768px) {
  .payment-container {
    padding: 20px;
    margin: 10px;
  }

  .payment-actions {
    flex-direction: column;
  }

  .amount-card {
    flex-direction: column;
    gap: 10px;
    text-align: center;
  }

  .debug-info {
    font-size: 0.8rem;
  }
}

/* Loading Animation */
.spinner-border-sm {
  width: 1rem;
  height: 1rem;
}

@keyframes spinner-border {
  to {
    transform: rotate(360deg);
  }
}

.spinner-border {
  display: inline-block;
  width: 2rem;
  height: 2rem;
  vertical-align: text-bottom;
  border: 0.25em solid currentColor;
  border-right-color: transparent;
  border-radius: 50%;
  animation: spinner-border 0.75s linear infinite;
}


================================================
File: app/payment/payment.component.html
================================================
<div class="payment-container" *ngIf="showPayment">
  <!-- Payment Header -->
  <div class="payment-header">
    <h4>Complete Your Payment</h4>
    <p class="text-muted">Secure payment powered by Stripe</p>
  </div>

  <!-- Payment Amount -->
  <div class="payment-amount">
    <div class="amount-card">
      <span class="amount-label">Property Listing Fee:</span>
      <span class="amount-value">${{ paymentAmount }}</span>
    </div>
  </div>

  <!-- Stripe Card Element -->
  <div class="card-section">
    <label for="card-element-stripe">Credit or Debit Card</label>
    <div id="card-element" class="stripe-card" role="textbox" aria-label="Credit or debit card input">
      <!-- Stripe Elements سيضع الكارت هنا -->
    </div>
    
    <!-- ZIP Code منفصل (اختياري) -->
    <div class="row mt-3" *ngIf="showSeparateZip">
      <div class="col-md-6">
        <label for="billing-zip">ZIP / Postal Code</label>
        <input 
          type="text" 
          id="billing-zip"
          [(ngModel)]="billingZip"
          class="form-control"
          placeholder="12345"
          maxlength="10">
      </div>
    </div>
    
    <div id="card-errors" class="error-message" role="alert" aria-live="polite"></div>
  </div>

  <!-- Submit Button -->
  <div class="payment-actions">
    <button 
      class="btn btn-secondary" 
      (click)="cancelPayment()"
      [disabled]="isProcessing">
      Cancel
    </button>
    
    <button 
      class="btn btn-primary payment-btn"
      (click)="handlePayment()"
      [disabled]="isProcessing || !isCardElementReady">
      <span *ngIf="!isProcessing">
        <i class="bi bi-lock"></i>
        Pay ${{ paymentAmount }}
      </span>
      <span *ngIf="isProcessing">
        <span class="spinner-border spinner-border-sm me-2"></span>
        Processing...
      </span>
    </button>
  </div>

  <!-- Debug Info -->
  <div class="debug-info mt-3 p-2 bg-light rounded small" *ngIf="showDebug">
    <strong>Debug Info:</strong><br>
    Stripe Loaded: {{ stripeLoaded }}<br>
    Card Ready: {{ isCardElementReady }}<br>
    Processing: {{ isProcessing }}<br>
    <button class="btn btn-sm btn-warning mt-2" (click)="retryCardSetup()" *ngIf="!isCardElementReady">
      🔄 Retry Card Setup
    </button>
    <button class="btn btn-sm btn-info mt-2" (click)="testStripe()">
      🧪 Test Stripe
    </button>
  </div>

  <!-- Security Notice -->
  <div class="security-notice">
    <i class="bi bi-shield-check text-success"></i>
    <span>Your payment information is encrypted and secure</span>
  </div>
</div>


================================================
File: app/payment/payment.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { PaymentComponent } from './payment.component';

describe('PaymentComponent', () => {
  let component: PaymentComponent;
  let fixture: ComponentFixture<PaymentComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PaymentComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(PaymentComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/payment/payment.component.ts
================================================
import { Component, Input, Output, EventEmitter, OnInit, AfterViewInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { PaymentService } from '../services/payment.service';
import Swal from 'sweetalert2';

declare var Stripe: any;

@Component({
  selector: 'app-payment',
  standalone: true,
  imports: [CommonModule, FormsModule],
  templateUrl: './payment.component.html',
  styleUrls: ['./payment.component.css']
})
export class PaymentComponent implements OnInit, AfterViewInit, OnDestroy {
  @Input() showPayment = false;
  @Input() paymentAmount = 50;
  @Output() paymentSuccess = new EventEmitter<any>();
  @Output() paymentCancel = new EventEmitter<void>();

  // Public properties for template
  isProcessing = false;
  stripeLoaded = false;
  isCardElementReady = false;
  showDebug = true; // غير لـ false في Production
  showSeparateZip = false; // غير لـ true لو عايز ZIP منفصل
  billingZip = ''; // للـ ZIP code المنفصل

  // Private Stripe properties
  private stripe: any;
  private elements: any;
  private cardElement: any;

  // Stripe Publishable Key
  private readonly stripePublishableKey = 'pk_test_51RXPxIRHB8EWOr5UtIiT6dVRn7j68SFzmO6kKiJpfLoh58o9kj5h3kb8QTpvnhaqLOVPB5ladvNBHHrQrR2Q9XdH00Q2gtWAQ5';

  constructor(private paymentService: PaymentService) {}

  ngOnInit() {
    console.log('🚀 PaymentComponent initialized');
    this.loadStripe();
  }

  ngAfterViewInit() {
    if (this.showPayment) {
      // جرب أكتر من مرة عشان تتأكد إن الـ DOM جاهز
      setTimeout(() => this.initializeStripeElements(), 100);
      setTimeout(() => this.initializeStripeElements(), 500);
      setTimeout(() => this.initializeStripeElements(), 1000);
    }
  }

  ngOnDestroy() {
    if (this.cardElement) {
      try {
        this.cardElement.destroy();
      } catch (error) {
        console.log('Card element already destroyed');
      }
    }
  }

  private loadStripe() {
    console.log('🔄 Loading Stripe...');
    
    if (typeof Stripe === 'undefined') {
      console.log('📦 Stripe not found, loading script...');
      const script = document.createElement('script');
      script.src = 'https://js.stripe.com/v3/';
      script.onload = () => {
        console.log('✅ Stripe script loaded');
        this.stripeLoaded = true;
        this.initializeStripeElements();
      };
      script.onerror = () => {
        console.error('❌ Failed to load Stripe script');
      };
      document.head.appendChild(script);
    } else {
      console.log('✅ Stripe already loaded');
      this.stripeLoaded = true;
      this.initializeStripeElements();
    }
  }

  private initializeStripeElements() {
    // تحقق من إن الـ element مش مُهيأ قبل كده
    if (!this.showPayment || typeof Stripe === 'undefined' || this.isCardElementReady) {
      console.log('⏭️ Skipping Stripe initialization', {
        showPayment: this.showPayment,
        stripeAvailable: typeof Stripe !== 'undefined',
        cardReady: this.isCardElementReady
      });
      return;
    }

    try {
      console.log('🔄 Initializing Stripe Elements...');
      
      // Initialize Stripe (لو مش مُهيأ)
      if (!this.stripe) {
        this.stripe = Stripe(this.stripePublishableKey);
        console.log('✅ Stripe initialized');
      }
      
      // Create Elements instance (لو مش موجود)
      if (!this.elements) {
        this.elements = this.stripe.elements();
        console.log('✅ Elements created');
      }
      
      // Create card element (لو مش موجود)
      if (!this.cardElement) {
        this.cardElement = this.elements.create('card', {
          style: {
            base: {
              fontSize: '16px',
              color: '#424770',
              fontFamily: '"Segoe UI", Tahoma, Geneva, Verdana, sans-serif',
              '::placeholder': {
                color: '#aab7c4',
              },
            },
            invalid: {
              color: '#dc3545',
              iconColor: '#dc3545'
            }
          },
          hidePostalCode: true // إخفاء الـ ZIP code لتجنب المشاكل
        });
        console.log('✅ Card element created');
        
        // Handle card ready event
        this.cardElement.on('ready', () => {
          console.log('✅ Card element is ready');
          this.isCardElementReady = true;
        });
        
        // Handle card changes
        this.cardElement.on('change', (event: any) => {
          console.log('🔄 Card change event:', event);
          const displayError = document.getElementById('card-errors');
          if (displayError) {
            if (event.error) {
              displayError.textContent = event.error.message;
            } else {
              displayError.textContent = '';
            }
          }
        });
      }
      
      // Mount card element
      const cardElementContainer = document.getElementById('card-element');
      if (cardElementContainer && this.cardElement && !cardElementContainer.hasChildNodes()) {
        this.cardElement.mount('#card-element');
        console.log('✅ Card element mounted, waiting for ready event...');
        
        // إضافة accessibility attributes للـ card element
        setTimeout(() => {
          const iframeElement = cardElementContainer.querySelector('iframe');
          if (iframeElement) {
            iframeElement.setAttribute('title', 'Secure card payment input');
            iframeElement.setAttribute('aria-label', 'Enter your card details');
          }
        }, 1000);
      } else if (cardElementContainer?.hasChildNodes()) {
        console.log('✅ Card element already mounted');
        this.isCardElementReady = true;
      } else {
        console.error('❌ Card element container not found');
        console.log('Available elements:', document.querySelectorAll('[id*="card"]'));
      }
      
    } catch (error) {
      console.error('❌ Error initializing Stripe:', error);
    }
  }

  async handlePayment() {
    if (!this.stripe || !this.cardElement || this.isProcessing) {
      console.log('❌ Payment blocked:', { 
        stripe: !!this.stripe, 
        cardElement: !!this.cardElement, 
        isProcessing: this.isProcessing 
      });
      return;
    }

    this.isProcessing = true;
    this.clearErrors();

    try {
      console.log('🔄 Creating payment intent for $', this.paymentAmount);
      
      // 1. Create payment intent from backend
      const paymentIntentResponse = await this.paymentService.createPaymentIntent({
        currency: 'usd',
        amount: this.paymentAmount * 100 // Convert to cents
      }).toPromise();

      console.log('✅ Payment intent response:', paymentIntentResponse);

      if (!paymentIntentResponse?.clientSecret) {
        throw new Error('Failed to create payment intent - no client secret received');
      }

      console.log('🔄 Confirming payment with Stripe...');

      // 2. Confirm payment with Stripe
      const { error, paymentIntent } = await this.stripe.confirmCardPayment(
        paymentIntentResponse.clientSecret,
        {
          payment_method: {
            card: this.cardElement,
            billing_details: {
              name: 'Property Owner',
              address: this.showSeparateZip && this.billingZip ? {
                postal_code: this.billingZip
              } : undefined
            },
          }
        }
      );

      if (error) {
        console.error('❌ Payment confirmation error:', error);
        this.showError(error.message || 'Payment failed. Please try again.');
      } else if (paymentIntent.status === 'succeeded') {
        console.log('✅ Payment succeeded:', paymentIntent);
        
        await Swal.fire({
          icon: 'success',
          title: 'Payment Successful!',
          text: 'Your payment has been processed successfully.',
          confirmButtonColor: '#08227B',
          timer: 3000,
          showConfirmButton: true
        });

        this.paymentSuccess.emit({
          paymentIntentId: paymentIntent.id,
          amount: this.paymentAmount,
          status: paymentIntent.status
        });
      } else {
        throw new Error(`Payment status: ${paymentIntent.status}`);
      }

    } catch (error: any) {
      console.error('❌ Payment error:', error);
      
      let errorMessage = 'An unexpected error occurred. Please try again.';
      
      if (error.status === 401) {
        errorMessage = 'Please log in again to continue.';
      } else if (error.status === 400) {
        errorMessage = 'Invalid payment request. Please check your information.';
      } else if (error.status === 500) {
        errorMessage = 'Server error. Please try again later.';
      } else if (error.message) {
        errorMessage = error.message;
      }
      
      this.showError(errorMessage);
    } finally {
      this.isProcessing = false;
    }
  }

  private showError(message: string) {
    const errorDiv = document.getElementById('card-errors');
    if (errorDiv) {
      errorDiv.textContent = message;
    }
    
    Swal.fire({
      icon: 'error',
      title: 'Payment Failed',
      text: message,
      confirmButtonColor: '#08227B'
    });
  }

  private clearErrors() {
    const errorDiv = document.getElementById('card-errors');
    if (errorDiv) {
      errorDiv.textContent = '';
    }
  }

  cancelPayment() {
    console.log('❌ Payment cancelled by user');
    this.paymentCancel.emit();
  }

  // Retry method للـ Card Setup
  retryCardSetup() {
    console.log('🔄 Retrying card setup...');
    this.isCardElementReady = false;
    
    // إزالة الـ card element السابق لو موجود
    if (this.cardElement) {
      try {
        this.cardElement.unmount();
        this.cardElement.destroy();
        this.cardElement = null;
      } catch (error) {
        console.log('Card element was not mounted');
      }
    }
    
    // إعادة تهيئة
    setTimeout(() => {
      this.initializeStripeElements();
    }, 500);
  }

  // Test method للتشخيص
  testStripe() {
    console.log('🧪 Testing Stripe setup...');
    console.log('Stripe loaded:', !!this.stripe);
    console.log('Elements loaded:', !!this.elements);
    console.log('Card element ready:', !!this.cardElement);
    console.log('Card element mounted:', this.isCardElementReady);
    
    // Test card element mount
    const cardContainer = document.getElementById('card-element');
    console.log('Card container found:', !!cardContainer);
    console.log('Card container has children:', cardContainer?.hasChildNodes());
    
    // Test Stripe object
    if (this.stripe) {
      console.log('Stripe version:', this.stripe.version || 'Unknown');
    }
  }
}


================================================
File: app/profile/profile.component.css
================================================
.profile-container {
  min-height: 100vh;
  background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 50vh;
}

.profile-header {
  background: white;
  border-radius: 20px;
  padding: 30px;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

.profile-image-container {
  position: relative;
  display: inline-block;
  overflow: hidden; /* Hide any overflow text */
  border-radius: 50%; /* Make container circular to contain icons */
}

.profile-image {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #08227B;
  box-shadow: 0 4px 15px rgba(8, 34, 123, 0.3);
  position: absolute;
  top: 0;
  left: 0;
  display: block; /* Ensure image display */
}

.profile-image.default-image {
  position: relative;
  opacity: 1;
  z-index: 1; /* الطبقة السفلى - الصورة الافتراضية */
}

.profile-image.user-image {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2; /* الطبقة الوسطى - صورة المستخدم */
}

.header-image-actions {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  pointer-events: none; /* Allow clicks to pass through container */
}

.header-edit-btn,
.header-remove-btn {
  position: absolute;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  border: 2px solid white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.3s ease;
  pointer-events: auto; /* Enable clicks on buttons */
}

.header-edit-btn {
  bottom: 5px;
  right: 5px;
  background: #08227B;
  color: white;
}

.header-edit-btn:hover {
  background: #061a5f;
  transform: scale(1.1);
}

.header-remove-btn {
  bottom: 5px;
  left: 5px;
  background: #dc3545;
  color: white;
}

.header-remove-btn:hover {
  background: #c82333;
  transform: scale(1.1);
}

.user-name {
  color: #08227B;
  font-weight: bold;
  margin: 0;
  font-size: 1.8rem;
}

.header-actions {
  display: flex;
  gap: 10px;
}

.action-btn {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  cursor: pointer;
  transition: all 0.3s ease;
}

.edit-btn {
  background: #28a745;
  color: white;
}

.edit-btn:hover {
  background: #218838;
  transform: scale(1.1);
}

.logout-btn {
  background: #dc3545;
  color: white;
}

.logout-btn:hover {
  background: #c82333;
  transform: scale(1.1);
}

.section-container {
  background: white;
  border-radius: 15px;
  padding: 25px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
}

.section-title {
  color: #08227B;
  font-weight: bold;
  font-size: 1.3rem;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 2px solid #f8f9fa;
}

.menu-items {
  display: flex;
  flex-direction: column;
  gap: 0;
}

.menu-item {
  display: flex;
  align-items: center;
  padding: 20px;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  border-bottom: 1px solid #f1f3f4;
}

.menu-item:hover {
  background: #f8f9fa;
  transform: translateX(5px);
}

.menu-item:last-child {
  border-bottom: none;
}

.menu-icon {
  width: 50px;
  height: 50px;
  border-radius: 12px;
  background: #e9ecef;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3rem;
  color: #08227B;
  margin-right: 15px;
}

.menu-content {
  flex: 1;
}

.menu-content h5 {
  margin: 0 0 5px 0;
  font-weight: 600;
  color: #333;
}

.menu-content p {
  margin: 0;
  color: #6c757d;
  font-size: 0.9rem;
}

.menu-arrow {
  color: #6c757d;
  font-size: 1.1rem;
}

.menu-toggle {
  margin-right: 10px;
}

.menu-badge {
  margin-right: 10px;
}

.form-check-input:checked {
  background-color: #08227B;
  border-color: #08227B;
}

.delete-section {
  border: 2px solid #ffeeba;
  background: #fff3cd;
}

.delete-account-item {
  display: flex;
  align-items: center;
  padding: 20px;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.delete-account-item:hover {
  background: rgba(220, 53, 69, 0.1);
  transform: translateX(5px);
}

/* Modal Styles */
.modal {
  background: rgba(0, 0, 0, 0.5);
}

.modal.show {
  display: block !important;
}

.modal-content {
  border-radius: 15px;
  border: none;
  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
}

.modal-header {
  background: #08227B;
  color: white;
  border-radius: 15px 15px 0 0;
  border-bottom: none;
}

.modal-title {
  font-weight: bold;
}

.btn-close {
  filter: invert(1);
}

.edit-image-container {
  position: relative;
  display: inline-block;
  overflow: hidden; /* Hide any overflow text */
}

.edit-profile-image {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  object-fit: cover;
  border: 4px solid #08227B;
  position: absolute;
  top: 0;
  left: 0;
  display: block; /* Ensure image display */
}

.edit-profile-image.default-image {
  position: relative;
  opacity: 1;
  z-index: 1; /* الطبقة السفلى - الصورة الافتراضية */
}

.edit-profile-image.user-image {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 2; /* الطبقة الوسطى - صورة المستخدم */
}

.image-upload-btn {
  position: absolute;
  bottom: 0;
  right: 0;
  width: 40px;
  height: 40px;
  background: #08227B;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: 3px solid white;
  font-size: 1.2rem;
  transition: all 0.3s ease;
}

.image-upload-btn:hover {
  background: #061a5f;
  transform: scale(1.1);
}

.image-remove-btn {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 40px;
  height: 40px;
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border: 3px solid white;
  font-size: 1.1rem;
  transition: all 0.3s ease;
}

.image-remove-btn:hover {
  background: #c82333;
  transform: scale(1.1);
}

.btn-primary {
  background-color: #08227B;
  border-color: #08227B;
}

.btn-primary:hover {
  background-color: #061a5f;
  border-color: #061a5f;
}

.form-control:focus {
  border-color: #08227B;
  box-shadow: 0 0 0 0.2rem rgba(8, 34, 123, 0.25);
}

.form-select:focus {
  border-color: #08227B;
  box-shadow: 0 0 0 0.2rem rgba(8, 34, 123, 0.25);
}

.modal-backdrop {
  background: rgba(0, 0, 0, 0.5);
}

.modal-backdrop.show {
  opacity: 1;
}

/* Dark Mode Styles */
body.dark-mode .profile-container {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
}

body.dark-mode .profile-header,
body.dark-mode .section-container {
  background: #2d3748;
  color: white;
}

body.dark-mode .menu-item:hover {
  background: #4a5568;
}

body.dark-mode .menu-icon {
  background: #4a5568;
  color: #08227B;
}

body.dark-mode .menu-content h5 {
  color: white;
}

body.dark-mode .menu-content p {
  color: #a0aec0;
}

body.dark-mode .delete-section {
  background: #744210;
  border-color: #d69e2e;
}

/* Responsive Design */
@media (max-width: 768px) {
  .profile-header {
    padding: 20px;
  }
  
  .user-name {
    font-size: 1.4rem;
  }
  
  .profile-image {
    width: 60px;
    height: 60px;
  }
  
  .profile-image-container {
    width: 60px;
    height: 60px;
  }
  
  .edit-image-section {
    flex-direction: column;
    gap: 15px;
  }
  
  .image-actions {
    flex-direction: row;
    gap: 10px;
  }
  
  .edit-profile-image {
    width: 100px;
    height: 100px;
  }
  
  .edit-image-container {
    width: 100px;
    height: 100px;
  }
  
  .image-action-btn {
    width: 40px;
    height: 40px;
    font-size: 1rem;
  }
  
  .action-btn {
    width: 45px;
    height: 45px;
    font-size: 1rem;
  }
  
  .menu-item {
    padding: 15px;
  }
  
  .menu-icon {
    width: 45px;
    height: 45px;
    font-size: 1.1rem;
  }
  
  .section-container {
    padding: 20px;
  }
}


================================================
File: app/profile/profile.component.html
================================================
<!-- Profile Component HTML -->
<div class="profile-container">
  <!-- Loading State -->
  <div *ngIf="isLoading" class="loading-container">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
    <p class="mt-3">Loading profile...</p>
  </div>

  <!-- Profile Content -->
  <div *ngIf="!isLoading" class="container py-4">
    <!-- Profile Header -->
    <div class="profile-header mb-4">
      <div class="row align-items-center">
        <div class="col-auto">
          <div class="profile-image-container">
            <img 
              [src]="getUserImageUrl()" 
              alt="Profile Picture" 
              class="profile-image"
              onerror="this.src='assets/images/unknown.png'"
            >
          </div>
        </div>
        <div class="col">
          <h2 class="user-name">{{ getUserFullName() }}</h2>
        </div>
        <div class="col-auto">
          <div class="header-actions">
            <button class="action-btn edit-btn" (click)="openEditModal()" title="Edit Profile">
              <i class="bi bi-pencil"></i>
            </button>
            <button class="action-btn logout-btn" (click)="logout()" title="Sign Out">
              <i class="bi bi-box-arrow-right"></i>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Account Section -->
    <div class="section-container mb-4">
      <h3 class="section-title">
        <i class="bi bi-person-circle"></i> Account
      </h3>
      <div class="menu-items">
        <div class="menu-item" (click)="navigateToAddProperty()">
          <div class="menu-icon">
            <i class="bi bi-house-add"></i>
          </div>
          <div class="menu-content">
            <h5>Upload Your Property</h5>
            <p>Add a new property to the platform</p>
          </div>
          <div class="menu-arrow">
            <i class="bi bi-chevron-right"></i>
          </div>
        </div>

        <div class="menu-item" (click)="openEditModal()">
          <div class="menu-icon">
            <i class="bi bi-person-gear"></i>
          </div>
          <div class="menu-content">
            <h5>Edit Profile</h5>
            <p>Update your personal information</p>
          </div>
          <div class="menu-arrow">
            <i class="bi bi-chevron-right"></i>
          </div>
        </div>

        <div class="menu-item" (click)="openPasswordModal()">
          <div class="menu-icon">
            <i class="bi bi-lock"></i>
          </div>
          <div class="menu-content">
            <h5>Change Password</h5>
            <p>Update your account password</p>
          </div>
          <div class="menu-arrow">
            <i class="bi bi-chevron-right"></i>
          </div>
        </div>
      </div>
    </div>

    <!-- More Section -->
    <div class="section-container mb-4">
      <h3 class="section-title">
        <i class="bi bi-three-dots"></i> More
      </h3>
      <div class="menu-items">
        <div class="menu-item" (click)="showAboutUs()">
          <div class="menu-icon">
            <i class="bi bi-info-circle"></i>
          </div>
          <div class="menu-content">
            <h5>About Us</h5>
            <p>Learn more about X-Rental platform</p>
          </div>
          <div class="menu-arrow">
            <i class="bi bi-chevron-right"></i>
          </div>
        </div>

        <div class="menu-item">
          <div class="menu-icon">
            <i class="bi bi-moon"></i>
          </div>
          <div class="menu-content">
            <h5>Dark Mode</h5>
            <p>Switch between light and dark theme</p>
          </div>
          <div class="menu-toggle">
            <div class="form-check form-switch">
              <input 
                class="form-check-input" 
                type="checkbox" 
                id="darkModeSwitch"
                [checked]="isDarkMode"
                (change)="toggleDarkMode()"
              >
            </div>
          </div>
        </div>

        <div class="menu-item">
          <div class="menu-icon">
            <i class="bi bi-globe"></i>
          </div>
          <div class="menu-content">
            <h5>Language</h5>
            <p>العربية - Arabic</p>
          </div>
          <div class="menu-badge">
            <span class="badge bg-secondary">Static</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Delete Account Section -->
    <div class="section-container delete-section">
      <div class="delete-account-item" (click)="deleteAccount()">
        <div class="menu-icon text-danger">
          <i class="bi bi-trash"></i>
        </div>
        <div class="menu-content">
          <h5 class="text-danger">Delete Account</h5>
          <p class="text-muted">Permanently delete your account and data</p>
        </div>
        <div class="menu-arrow text-danger">
          <i class="bi bi-chevron-right"></i>
        </div>
      </div>
    </div>
  </div>

  <!-- Edit Profile Modal -->
  <div class="modal" [class.show]="showEditModal" [style.display]="showEditModal ? 'block' : 'none'">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">
            <i class="bi bi-person-gear"></i> Edit Profile
          </h5>
          <button type="button" class="btn-close" (click)="closeEditModal()"></button>
        </div>
        <div class="modal-body">
          <form [formGroup]="profileForm" (ngSubmit)="onUpdateProfile()">
            <!-- Profile Image Section -->
            <div class="text-center mb-4">
              <div class="edit-image-section">
                <div class="edit-image-container">
                  <!-- الطبقة الأولى (السفلى): الصورة الافتراضية - z-index: 1 -->
                  <img 
                    src="assets/images/unkown.png" 
                    alt="Profile Picture" 
                    class="edit-profile-image default-image"
                  >
                  <!-- الطبقة الثانية (الوسطى): صورة المستخدم - z-index: 2 -->
                  <img 
                    *ngIf="hasUserImage()"
                    [src]="getUserActualImageUrl()" 
                    alt="User Profile Picture" 
                    class="edit-profile-image user-image"
                    onerror="this.style.display='none'"
                  >
                </div>
                
                <!-- أيقونات بجانب الصورة -->
                <div class="image-actions">
                  <label for="profileImageInput" class="image-action-btn upload-btn" title="Change Photo">
                    <i class="bi bi-camera"></i>
                  </label>
                  <button 
                    type="button" 
                    class="image-action-btn remove-btn" 
                    *ngIf="hasUserImage()"
                    (click)="removeProfileImage()"
                    title="Remove Photo"
                  >
                    <i class="bi bi-trash"></i>
                  </button>
                </div>
              </div>
              
              <input 
                type="file" 
                id="profileImageInput"
                class="d-none"
                accept="image/*"
                (change)="onFileSelected($event)"
              >
              <div class="mt-2">
                <div *ngIf="selectedFile" class="text-success">
                  <small>
                    <i class="bi bi-check-circle"></i> New image selected: {{ selectedFile.name }}
                  </small>
                </div>
                <div *ngIf="isImageDeleted" class="text-warning">
                  <small>
                    <i class="bi bi-exclamation-triangle"></i> Profile picture will be removed
                  </small>
                </div>
                <div *ngIf="!selectedFile && !isImageDeleted && !hasUserImage()" class="text-muted">
                  <small>Click camera icon to add your photo</small>
                </div>
              </div>
            </div>

            <div class="row">
              <div class="col-md-6">
                <div class="mb-3">
                  <label for="firstName" class="form-label">First Name *</label>
                  <input 
                    type="text" 
                    id="firstName"
                    formControlName="firstName" 
                    class="form-control"
                    [class.is-invalid]="profileForm.get('firstName')?.invalid && profileForm.get('firstName')?.touched"
                  >
                  <div *ngIf="profileForm.get('firstName')?.invalid && profileForm.get('firstName')?.touched" class="invalid-feedback">
                    <div *ngIf="profileForm.get('firstName')?.errors?.['required']">First name is required</div>
                    <div *ngIf="profileForm.get('firstName')?.errors?.['minlength']">First name must be at least 2 characters</div>
                  </div>
                </div>
              </div>
              
              <div class="col-md-6">
                <div class="mb-3">
                  <label for="lastName" class="form-label">Last Name *</label>
                  <input 
                    type="text" 
                    id="lastName"
                    formControlName="lastName" 
                    class="form-control"
                    [class.is-invalid]="profileForm.get('lastName')?.invalid && profileForm.get('lastName')?.touched"
                  >
                  <div *ngIf="profileForm.get('lastName')?.invalid && profileForm.get('lastName')?.touched" class="invalid-feedback">
                    <div *ngIf="profileForm.get('lastName')?.errors?.['required']">Last name is required</div>
                    <div *ngIf="profileForm.get('lastName')?.errors?.['minlength']">Last name must be at least 2 characters</div>
                  </div>
                </div>
              </div>
            </div>

            <div class="row">
              <div class="col-md-6">
                <div class="mb-3">
                  <label for="email" class="form-label">Email *</label>
                  <input 
                    type="email" 
                    id="email"
                    formControlName="email" 
                    class="form-control"
                    [class.is-invalid]="profileForm.get('email')?.invalid && profileForm.get('email')?.touched"
                  >
                  <div *ngIf="profileForm.get('email')?.invalid && profileForm.get('email')?.touched" class="invalid-feedback">
                    <div *ngIf="profileForm.get('email')?.errors?.['required']">Email is required</div>
                    <div *ngIf="profileForm.get('email')?.errors?.['email']">Please enter a valid email</div>
                  </div>
                </div>
              </div>
              
              <div class="col-md-6">
                <div class="mb-3">
                  <label for="phoneNumber" class="form-label">Phone Number</label>
                  <input 
                    type="tel" 
                    id="phoneNumber"
                    formControlName="phoneNumber" 
                    class="form-control"
                    [class.is-invalid]="profileForm.get('phoneNumber')?.invalid && profileForm.get('phoneNumber')?.touched"
                  >
                  <div *ngIf="profileForm.get('phoneNumber')?.invalid && profileForm.get('phoneNumber')?.touched" class="invalid-feedback">
                    Please enter a valid phone number
                  </div>
                </div>
              </div>
            </div>

            <div class="mb-3">
              <label for="city" class="form-label">City</label>
              <select formControlName="city" id="city" class="form-select">
                <option value="">Select city</option>
                <option value="Cairo">Cairo</option>
                <option value="Alexandria">Alexandria</option>
                <option value="Giza">Giza</option>
                <option value="Luxor">Luxor</option>
                <option value="Aswan">Aswan</option>
                <option value="Sharm El Sheikh">Sharm El Sheikh</option>
                <option value="Hurghada">Hurghada</option>
              </select>
            </div>
          </form>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" (click)="closeEditModal()">Cancel</button>
          <button 
            type="button" 
            class="btn btn-primary"
            [disabled]="isUpdatingProfile || profileForm.invalid"
            (click)="onUpdateProfile()"
          >
            <span *ngIf="!isUpdatingProfile">
              <i class="bi bi-check-circle"></i> Update Profile
            </span>
            <span *ngIf="isUpdatingProfile">
              <span class="spinner-border spinner-border-sm me-2"></span>
              Updating...
            </span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Change Password Modal -->
  <div class="modal" [class.show]="showPasswordModal" [style.display]="showPasswordModal ? 'block' : 'none'">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title">
            <i class="bi bi-lock"></i> Change Password
          </h5>
          <button type="button" class="btn-close" (click)="closePasswordModal()"></button>
        </div>
        <div class="modal-body">
          <form [formGroup]="passwordForm" (ngSubmit)="onChangePassword()">
            <div class="mb-3">
              <label for="oldPassword" class="form-label">Current Password *</label>
              <input 
                type="password" 
                id="oldPassword"
                formControlName="oldPassword" 
                class="form-control"
                [class.is-invalid]="passwordForm.get('oldPassword')?.invalid && passwordForm.get('oldPassword')?.touched"
              >
              <div *ngIf="passwordForm.get('oldPassword')?.invalid && passwordForm.get('oldPassword')?.touched" class="invalid-feedback">
                Current password is required
              </div>
            </div>

            <div class="mb-3">
              <label for="newPassword" class="form-label">New Password *</label>
              <input 
                type="password" 
                id="newPassword"
                formControlName="newPassword" 
                class="form-control"
                [class.is-invalid]="passwordForm.get('newPassword')?.invalid && passwordForm.get('newPassword')?.touched"
              >
              <div *ngIf="passwordForm.get('newPassword')?.invalid && passwordForm.get('newPassword')?.touched" class="invalid-feedback">
                <div *ngIf="passwordForm.get('newPassword')?.errors?.['required']">New password is required</div>
                <div *ngIf="passwordForm.get('newPassword')?.errors?.['minlength']">Password must be at least 6 characters</div>
              </div>
            </div>
            
            <div class="mb-3">
              <label for="confirmNewPassword" class="form-label">Confirm New Password *</label>
              <input 
                type="password" 
                id="confirmNewPassword"
                formControlName="confirmNewPassword" 
                class="form-control"
                [class.is-invalid]="passwordForm.get('confirmNewPassword')?.invalid && passwordForm.get('confirmNewPassword')?.touched"
              >
              <div *ngIf="passwordForm.get('confirmNewPassword')?.invalid && passwordForm.get('confirmNewPassword')?.touched" class="invalid-feedback">
                <div *ngIf="passwordForm.get('confirmNewPassword')?.errors?.['required']">Please confirm your password</div>
                <div *ngIf="passwordForm.get('confirmNewPassword')?.errors?.['mismatch']">Passwords do not match</div>
              </div>
            </div>
          </form>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" (click)="closePasswordModal()">Cancel</button>
          <button 
            type="button" 
            class="btn btn-warning"
            [disabled]="isChangingPassword || passwordForm.invalid"
            (click)="onChangePassword()"
          >
            <span *ngIf="!isChangingPassword">
              <i class="bi bi-key"></i> Change Password
            </span>
            <span *ngIf="isChangingPassword">
              <span class="spinner-border spinner-border-sm me-2"></span>
              Changing...
            </span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Backdrop -->
  <div class="modal-backdrop" 
       [class.show]="showEditModal || showPasswordModal" 
       [style.display]="(showEditModal || showPasswordModal) ? 'block' : 'none'"
       (click)="closeEditModal(); closePasswordModal()">
  </div>
</div>




================================================
File: app/profile/profile.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ProfileComponent } from './profile.component';

describe('ProfileComponent', () => {
  let component: ProfileComponent;
  let fixture: ComponentFixture<ProfileComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ProfileComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(ProfileComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/profile/profile.component.ts
================================================
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { Subscription } from 'rxjs';
import { AuthService, UserProfile } from '../services/auth.service';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-profile',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule],
  templateUrl: './profile.component.html',
  styleUrls: ['./profile.component.css']
})
export class ProfileComponent implements OnInit, OnDestroy {
  profileForm!: FormGroup;
  passwordForm!: FormGroup;
  currentUser: UserProfile | null = null;
  isLoading = false;
  isUpdatingProfile = false;
  isChangingPassword = false;
  selectedFile: File | null = null;
  imagePreview: string | null = null;
  showEditModal = false;
  showPasswordModal = false;
  isDarkMode = false;
  isImageDeleted = false;
  
  private subscriptions: Subscription[] = [];

  constructor(
    private formBuilder: FormBuilder,
    private authService: AuthService,
    private router: Router
  ) {
    // Load dark mode preference
    this.isDarkMode = localStorage.getItem('darkMode') === 'true';
    this.applyTheme();
  }

  ngOnInit(): void {
    // Check authentication
    if (!this.authService.isLoggedIn()) {
      this.router.navigate(['/log-in']);
      return;
    }

    this.initializeForms();
    this.loadUserProfile();
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }

  initializeForms(): void {
    this.profileForm = this.formBuilder.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]],
      phoneNumber: ['', Validators.pattern('^[+]?[0-9]{10,15}$')],
      city: ['']
    });

    this.passwordForm = this.formBuilder.group({
      oldPassword: ['', Validators.required],
      newPassword: ['', [Validators.required, Validators.minLength(6)]],
      confirmNewPassword: ['', Validators.required]
    }, {
      validators: this.passwordMatchValidator
    });
  }

  passwordMatchValidator(group: FormGroup) {
    const newPassword = group.get('newPassword');
    const confirmPassword = group.get('confirmNewPassword');
    
    if (newPassword && confirmPassword && newPassword.value !== confirmPassword.value) {
      confirmPassword.setErrors({ mismatch: true });
      return { mismatch: true };
    }
    
    return null;
  }

  loadUserProfile(): void {
    this.isLoading = true;
    
    const profileSub = this.authService.getUserProfile().subscribe({
      next: (profile: UserProfile) => {
        this.currentUser = profile;
        this.profileForm.patchValue({
          firstName: profile.firstName,
          lastName: profile.lastName,
          email: profile.email,
          phoneNumber: profile.phoneNumber,
          city: profile.city
        });
        this.imagePreview = profile.imageUrl || null;
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading profile:', error);
        this.isLoading = false;
        Swal.fire({
          icon: 'error',
          title: 'Error Loading Profile',
          text: 'Failed to load your profile information.',
          confirmButtonColor: '#08227B'
        });
      }
    });
    
    this.subscriptions.push(profileSub);
  }

  onFileSelected(event: any): void {
    const file = event.target.files[0];
    if (file) {
      // Validate file type
      if (!file.type.startsWith('image/')) {
        Swal.fire({
          icon: 'warning',
          title: 'Invalid File Type',
          text: 'Please select a valid image file.',
          confirmButtonColor: '#08227B'
        });
        return;
      }

      // Validate file size (max 5MB)
      if (file.size > 5 * 1024 * 1024) {
        Swal.fire({
          icon: 'warning',
          title: 'File Too Large',
          text: 'Please select an image smaller than 5MB.',
          confirmButtonColor: '#08227B'
        });
        return;
      }

      this.selectedFile = file;
      this.isImageDeleted = false;
      
      // Create preview
      const reader = new FileReader();
      reader.onload = (e: any) => {
        this.imagePreview = e.target.result;
      };
      reader.readAsDataURL(file);
    }
  }

  removeProfileImage(): void {
    Swal.fire({
      title: 'Remove Profile Picture',
      text: 'Are you sure you want to remove your profile picture?',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#d33',
      cancelButtonColor: '#6c757d',
      confirmButtonText: 'Yes, remove it',
      cancelButtonText: 'Cancel'
    }).then((result) => {
      if (result.isConfirmed) {
        this.selectedFile = null;
        this.imagePreview = null;
        this.isImageDeleted = true;
        
        // Clear file input
        const fileInput = document.getElementById('profileImageInput') as HTMLInputElement;
        if (fileInput) {
          fileInput.value = '';
        }
      }
    });
  }

  onUpdateProfile(): void {
    if (this.profileForm.invalid) {
      Object.keys(this.profileForm.controls).forEach(key => {
        this.profileForm.get(key)?.markAsTouched();
      });
      return;
    }

    this.isUpdatingProfile = true;

    // Prepare form data
    const formData = new FormData();
    const formValues = this.profileForm.value;
    
    // Add required fields
    formData.append('FirstName', formValues.firstName);
    formData.append('LastName', formValues.lastName);
    formData.append('Email', formValues.email);
    
    // Add optional fields
    if (formValues.phoneNumber) {
      formData.append('PhoneNumber', formValues.phoneNumber);
    } else {
      formData.append('PhoneNumber', '');
    }
    
    if (formValues.city) {
      formData.append('City', formValues.city);
    } else {
      formData.append('City', '');
    }

    // Handle image updates
    if (this.selectedFile) {
      // New image selected
      formData.append('Image', this.selectedFile);
    } else if (this.isImageDeleted) {
      // Image was deleted - send empty string or null
      formData.append('ImageUrl', '');
    } else if (this.currentUser?.imageUrl) {
      // Keep existing image
      formData.append('ImageUrl', this.currentUser.imageUrl);
    } else {
      // No image
      formData.append('ImageUrl', '');
    }

    const updateSub = this.authService.updateUserProfile(formData).subscribe({
      next: (response) => {
        this.isUpdatingProfile = false;
        this.showEditModal = false;
        Swal.fire({
          icon: 'success',
          title: 'Profile Updated',
          text: 'Your profile has been updated successfully!',
          showConfirmButton: false,
          timer: 1500
        });
        this.selectedFile = null;
        this.isImageDeleted = false;
        // Reload profile to get updated data
        this.loadUserProfile();
      },
      error: (error) => {
        this.isUpdatingProfile = false;
        console.error('Error updating profile:', error);
        
        let errorMessage = 'Failed to update profile. Please try again.';
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 500) {
          errorMessage = 'Server error. Please try again later or contact support.';
        }

        Swal.fire({
          icon: 'error',
          title: 'Update Failed',
          text: errorMessage,
          confirmButtonColor: '#08227B'
        });
      }
    });

    this.subscriptions.push(updateSub);
  }

  onChangePassword(): void {
    if (this.passwordForm.invalid) {
      Object.keys(this.passwordForm.controls).forEach(key => {
        this.passwordForm.get(key)?.markAsTouched();
      });
      return;
    }

    this.isChangingPassword = true;

    const passwordData = {
      oldPassword: this.passwordForm.value.oldPassword,
      newPassword: this.passwordForm.value.newPassword,
      confirmNewPassword: this.passwordForm.value.confirmNewPassword
    };

    const passwordSub = this.authService.changePassword(passwordData).subscribe({
      next: (response) => {
        this.isChangingPassword = false;
        this.showPasswordModal = false;
        this.passwordForm.reset();
        Swal.fire({
          icon: 'success',
          title: 'Password Changed',
          text: 'Your password has been changed successfully!',
          showConfirmButton: false,
          timer: 1500
        });
      },
      error: (error) => {
        this.isChangingPassword = false;
        console.error('Error changing password:', error);
        
        let errorMessage = 'Failed to change password. Please try again.';
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 400) {
          errorMessage = 'Current password is incorrect.';
        }

        Swal.fire({
          icon: 'error',
          title: 'Password Change Failed',
          text: errorMessage,
          confirmButtonColor: '#08227B'
        });
      }
    });

    this.subscriptions.push(passwordSub);
  }

  getUserImageUrl(): string {
    // Always return unkown.png as base (matching the actual filename)
    return 'assets/images/unkown.png';
  }

  getUserActualImageUrl(): string {
    if (this.isImageDeleted) {
      return '';
    }
    if (this.imagePreview) {
      return this.imagePreview;
    }
    if (this.currentUser?.imageUrl) {
      return this.currentUser.imageUrl;
    }
    return '';
  }

  hasUserImage(): boolean {
    return !this.isImageDeleted && (!!this.imagePreview || !!this.currentUser?.imageUrl);
  }

  getUserFullName(): string {
    if (this.currentUser) {
      return `${this.currentUser.firstName} ${this.currentUser.lastName}`;
    }
    return 'User Name';
  }

  logout(): void {
    Swal.fire({
      title: 'Sign Out',
      text: 'Are you sure you want to sign out?',
      icon: 'question',
      showCancelButton: true,
      confirmButtonColor: '#08227B',
      cancelButtonColor: '#6c757d',
      confirmButtonText: 'Yes, sign out',
      cancelButtonText: 'Cancel'
    }).then((result) => {
      if (result.isConfirmed) {
        this.authService.logout();
        this.router.navigate(['/log-in']);
      }
    });
  }

  deleteAccount(): void {
    Swal.fire({
      title: 'Are you sure?',
      text: 'Your account will be permanently deleted and cannot be recovered!',
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#d33',
      cancelButtonColor: '#08227B',
      confirmButtonText: 'Yes, delete account',
      cancelButtonText: 'Cancel'
    }).then((result) => {
      if (result.isConfirmed) {
        // Show second confirmation
        Swal.fire({
          title: 'Final Confirmation',
          text: 'This action cannot be undone. Do you want to continue?',
          icon: 'error',
          showCancelButton: true,
          confirmButtonColor: '#d33',
          cancelButtonColor: '#6c757d',
          confirmButtonText: 'Delete Permanently',
          cancelButtonText: 'Cancel'
        }).then((finalResult) => {
          if (finalResult.isConfirmed) {
            // Call delete account API (would need to be implemented)
            Swal.fire({
              icon: 'info',
              title: 'Coming Soon',
              text: 'Account deletion feature will be available soon.',
              confirmButtonColor: '#08227B'
            });
          }
        });
      }
    });
  }

  toggleDarkMode(): void {
    this.isDarkMode = !this.isDarkMode;
    localStorage.setItem('darkMode', this.isDarkMode.toString());
    this.applyTheme();
  }

  private applyTheme(): void {
    if (this.isDarkMode) {
      document.body.classList.add('dark-mode');
    } else {
      document.body.classList.remove('dark-mode');
    }
  }

  openEditModal(): void {
    this.showEditModal = true;
  }

  closeEditModal(): void {
    this.showEditModal = false;
    this.selectedFile = null;
    this.isImageDeleted = false;
    this.imagePreview = this.currentUser?.imageUrl || null;
    
    // Clear file input
    const fileInput = document.getElementById('profileImageInput') as HTMLInputElement;
    if (fileInput) {
      fileInput.value = '';
    }
  }

  openPasswordModal(): void {
    this.showPasswordModal = true;
  }

  closePasswordModal(): void {
    this.showPasswordModal = false;
    this.passwordForm.reset();
  }

  navigateToAddProperty(): void {
    this.router.navigate(['/add-property']);
  }

  showAboutUs(): void {
    Swal.fire({
      title: 'About Us',
      html: `
        <div style="text-align: left;">
          <h5>X-Rental Property Platform</h5>
          <p>We are a leading property rental platform in Egypt, helping property owners and tenants connect easily and securely.</p>
          
          <h6>Our Mission</h6>
          <p>To simplify the property rental process and make it accessible for everyone.</p>
          
          <h6>Contact Us</h6>
          <p>
            📧 Email: info@x-rental.com<br>
            📞 Phone: +20 123 456 7890<br>
            🌐 Website: www.x-rental.com
          </p>
        </div>
      `,
      confirmButtonColor: '#08227B',
      confirmButtonText: 'Close'
    });
  }
}


================================================
File: app/property-detail/property-detail.component.css
================================================



================================================
File: app/property-detail/property-detail.component.html
================================================
<!-- Property Detail Component HTML -->
<div class="container py-4" *ngIf="!isLoading && property">
  <!-- Back Button -->
  <div class="mb-3">
    <button class="btn btn-outline-primary" (click)="goBack()">
      <i class="bi bi-arrow-left"></i> Back to Properties
    </button>
  </div>

  <!-- Property Header -->
  <div class="row">
    <div class="col-12">
      <div class="d-flex justify-content-between align-items-start mb-3">
        <div>
          <h1 class="property-title">{{ property.title }}</h1>
          <p class="text-muted mb-2">
            <i class="bi bi-geo-alt"></i> {{ property.street }}, {{ property.city }}, {{ property.governate }}
          </p>
          <div class="property-meta">
            <span class="badge bg-primary me-2">{{ property.propertyType }}</span>
            <span class="text-muted">Listed {{ formatDate(property.listedAt) }}</span>
          </div>
        </div>
        <div class="text-end">
          <h2 class="price-tag">{{ formatPrice(property.price) }}</h2>
          <button class="btn btn-outline-danger" (click)="toggleFavorite()">
            <i class="bi" [ngClass]="{'bi-heart': !property.isFavorite, 'bi-heart-fill': property.isFavorite}"></i>
            {{ property.isFavorite ? 'Remove from Favorites' : 'Add to Favorites' }}
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Image Gallery -->
  <div class="row mb-4">
    <div class="col-lg-8">
      <div class="image-gallery">
        <div class="main-image-container" *ngIf="property.propertyImages.length > 0">
          <img 
            [src]="property.propertyImages[currentImageIndex]" 
            [alt]="property.title"
            class="main-image"
            
          >
          
          <!-- Navigation arrows -->
          <button class="image-nav prev" (click)="previousImage()" *ngIf="property.propertyImages.length > 1">
            <i class="bi bi-chevron-left"></i>
          </button>
          <button class="image-nav next" (click)="nextImage()" *ngIf="property.propertyImages.length > 1">
            <i class="bi bi-chevron-right"></i>
          </button>
          
          <!-- Image counter -->
          <div class="image-counter" *ngIf="property.propertyImages.length > 1">
            {{ currentImageIndex + 1 }} / {{ property.propertyImages.length }}
          </div>
        </div>
        
        <!-- Thumbnail gallery -->
        <div class="thumbnail-gallery" *ngIf="property.propertyImages.length > 1">
          <div class="row g-2">
            <div class="col-2" *ngFor="let image of property.propertyImages; let i = index">
              <img 
                #thumbImg
                [src]="image" 
                [alt]="property.title + ' - Image ' + (i + 1)"
                class="thumbnail"
                [class.active]="i === currentImageIndex"
                (click)="selectImage(i)"
                (error)="thumbImg.src='assets/images/apartment.avif'"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Property Info Sidebar -->
    <div class="col-lg-4">
      <div class="property-info-card">
        <h4>Property Details</h4>
        <div class="property-details">
          <div class="detail-row">
            <span class="detail-label">Size:</span>
            <span class="detail-value">{{ property.size }} m²</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Bedrooms:</span>
            <span class="detail-value">{{ property.bedrooms }}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Bathrooms:</span>
            <span class="detail-value">{{ property.bathrooms }}</span>
          </div>
          <div class="detail-row">
            <span class="detail-label">Type:</span>
            <span class="detail-value">{{ property.propertyType }}</span>
          </div>
        </div>

        <!-- Owner Info -->
        <div class="owner-info mt-4">
          <h5>Owner Information</h5>
          <p class="mb-1">
            <strong>{{ property.ownerInfo.firstName }} {{ property.ownerInfo.lastName }}</strong>
          </p>
          <p class="mb-1">
            <i class="bi bi-envelope"></i> {{ property.ownerInfo.email }}
          </p>
          <p class="mb-3">
            <i class="bi bi-phone"></i> {{ property.ownerInfo.phoneNumber }}
          </p>
          <button class="btn btn-success w-100" (click)="contactOwner()">
            <i class="bi bi-whatsapp"></i> Contact via WhatsApp
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Property Description -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="description-section">
        <h3>Description</h3>
        <p>{{ property.description }}</p>
      </div>
    </div>
  </div>

  <!-- Amenities -->
  <div class="row mb-4" *ngIf="property.internalAmenities.length > 0 || property.externalAmenities.length > 0 || property.accessibilityAmenities.length > 0">
    <div class="col-12">
      <div class="amenities-section">
        <h3>Amenities</h3>
        <div class="row">
          <div class="col-md-4" *ngIf="property.internalAmenities.length > 0">
            <h5>Internal Amenities</h5>
            <ul class="amenities-list">
              <li *ngFor="let amenity of property.internalAmenities">
                <i class="bi bi-check-circle text-success"></i> {{ amenity }}
              </li>
            </ul>
          </div>
          <div class="col-md-4" *ngIf="property.externalAmenities.length > 0">
            <h5>External Amenities</h5>
            <ul class="amenities-list">
              <li *ngFor="let amenity of property.externalAmenities">
                <i class="bi bi-check-circle text-success"></i> {{ amenity }}
              </li>
            </ul>
          </div>
          <div class="col-md-4" *ngIf="property.accessibilityAmenities.length > 0">
            <h5>Accessibility Features</h5>
            <ul class="amenities-list">
              <li *ngFor="let amenity of property.accessibilityAmenities">
                <i class="bi bi-check-circle text-success"></i> {{ amenity }}
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Reviews Section -->
  <div class="row">
    <div class="col-12">
      <div class="reviews-section">
        <h3>Reviews</h3>
        
        <!-- Add Review Form -->
        <div class="add-review-card mb-4" *ngIf="isLoggedIn">
          <h5>Leave a Review</h5>
          <form [formGroup]="reviewForm" (ngSubmit)="submitReview()">
            <div class="mb-3">
              <label class="form-label">Rating</label>
              <div class="star-rating">
                <div class="star-input">
                  <input type="radio" formControlName="rating" value="1" id="star1">
                  <label for="star1">⭐</label>
                  <input type="radio" formControlName="rating" value="2" id="star2">
                  <label for="star2">⭐</label>
                  <input type="radio" formControlName="rating" value="3" id="star3">
                  <label for="star3">⭐</label>
                  <input type="radio" formControlName="rating" value="4" id="star4">
                  <label for="star4">⭐</label>
                  <input type="radio" formControlName="rating" value="5" id="star5">
                  <label for="star5">⭐</label>
                </div>
              </div>
            </div>
            <div class="mb-3">
              <label class="form-label">Comment</label>
              <textarea 
                class="form-control" 
                formControlName="comment" 
                rows="3" 
                placeholder="Share your experience with this property..."
                [disabled]="isSubmittingReview"
              ></textarea>
              <div *ngIf="reviewForm.get('comment')?.invalid && reviewForm.get('comment')?.touched" class="text-danger small">
                Comment must be at least 10 characters long
              </div>
            </div>
            <button 
              type="submit" 
              class="btn btn-primary"
              [disabled]="reviewForm.invalid || isSubmittingReview"
            >
              <span *ngIf="!isSubmittingReview">Submit Review</span>
              <span *ngIf="isSubmittingReview">
                <span class="spinner-border spinner-border-sm me-2"></span>
                Submitting...
              </span>
            </button>
          </form>
        </div>

        <!-- Login prompt for guests -->
        <div class="alert alert-info" *ngIf="!isLoggedIn">
          <i class="bi bi-info-circle"></i>
          Please <a [routerLink]="['/log-in']" class="alert-link">log in</a> to leave a review.
        </div>

        <!-- Reviews List -->
        <div class="reviews-list">
          <div class="review-card" *ngFor="let review of reviews">
            <div class="review-header">
              <div class="reviewer-info">
                <strong>{{ review.userName || 'Anonymous' }}</strong>
                <div class="rating">
                  <span *ngFor="let star of getStarArray(review.rating)" class="star filled">⭐</span>
                  <span *ngFor="let star of getStarArray(5 - review.rating)" class="star">☆</span>
                </div>
              </div>
              <small class="text-muted">{{ formatDate(review.reviewDate || '') }}</small>
            </div>
            <p class="review-comment">{{ review.comment }}</p>
          </div>
          
          <div *ngIf="reviews.length === 0" class="no-reviews">
            <p class="text-muted text-center">No reviews yet. Be the first to review this property!</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Loading State -->
<div class="loading-container" *ngIf="isLoading">
  <div class="spinner-border text-primary" role="status">
    <span class="visually-hidden">Loading...</span>
  </div>
  <p>Loading property details...</p>
</div>


================================================
File: app/property-detail/property-detail.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { PropertyDetailComponent } from './property-detail.component';

describe('PropertyDetailComponent', () => {
  let component: PropertyDetailComponent;
  let fixture: ComponentFixture<PropertyDetailComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PropertyDetailComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(PropertyDetailComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/property-detail/property-detail.component.ts
================================================
import { Component, OnInit, OnDestroy } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, ReactiveFormsModule, FormBuilder, FormGroup, Validators } from '@angular/forms';
import { RouterModule, ActivatedRoute, Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { PropertyService, Property, Review } from '../services/property.service';
import { AuthService } from '../services/auth.service';
import Swal from 'sweetalert2';

@Component({
  selector: 'app-property-detail',
  standalone: true,
  imports: [CommonModule, FormsModule, ReactiveFormsModule, RouterModule],
  templateUrl: './property-detail.component.html',
  styleUrls: ['./property-detail.component.css']
})
export class PropertyDetailComponent implements OnInit, OnDestroy {
  property?: Property;
  reviews: Review[] = [];
  reviewForm!: FormGroup;
  currentImageIndex = 0;
  isLoading = true;
  isSubmittingReview = false;
  isLoggedIn = false;
  currentUser: any;
  
  private subscriptions: Subscription[] = [];

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private propertyService: PropertyService,
    private authService: AuthService,
    private formBuilder: FormBuilder
  ) {
    this.reviewForm = this.formBuilder.group({
      rating: [5, [Validators.required, Validators.min(1), Validators.max(5)]],
      comment: ['', [Validators.required, Validators.minLength(10)]]
    });
  }

  ngOnInit(): void {
    // Check authentication status
    this.isLoggedIn = this.authService.isLoggedIn();
    this.currentUser = this.authService.getUserData();

    // Subscribe to authentication changes
    const authSub = this.authService.currentUser$.subscribe(user => {
      this.isLoggedIn = !!user;
      this.currentUser = user;
    });
    this.subscriptions.push(authSub);

    // Get property ID from route
    const routeSub = this.route.params.subscribe(params => {
      const propertyId = +params['id'];
      if (propertyId) {
        this.loadProperty(propertyId);
        this.loadReviews(propertyId);
      }
    });
    this.subscriptions.push(routeSub);
  }

  ngOnDestroy(): void {
    this.subscriptions.forEach(sub => sub.unsubscribe());
  }

  loadProperty(propertyId: number): void {
    this.isLoading = true;
    const propertySub = this.propertyService.getPropertyById(propertyId).subscribe({
      next: (property) => {
        this.property = this.propertyService.formatProperty(property);
        this.isLoading = false;
      },
      error: (error) => {
        console.error('Error loading property:', error);
        this.isLoading = false;
        Swal.fire({
          icon: 'error',
          title: 'Property Not Found',
          text: 'The property you are looking for could not be found.',
          confirmButtonColor: '#08227B'
        }).then(() => {
          this.router.navigate(['/home']);
        });
      }
    });
    this.subscriptions.push(propertySub);
  }

  loadReviews(propertyId: number): void {
    const reviewsSub = this.propertyService.getPropertyReviews(propertyId).subscribe({
      next: (reviews) => {
        this.reviews = reviews;
      },
      error: (error) => {
        console.error('Error loading reviews:', error);
        // Reviews are optional, so we don't show error to user
      }
    });
    this.subscriptions.push(reviewsSub);
  }

  // Image carousel methods
  previousImage(): void {
    if (this.property && this.property.propertyImages.length > 0) {
      this.currentImageIndex = this.currentImageIndex > 0 
        ? this.currentImageIndex - 1 
        : this.property.propertyImages.length - 1;
    }
  }

  nextImage(): void {
    if (this.property && this.property.propertyImages.length > 0) {
      this.currentImageIndex = this.currentImageIndex < this.property.propertyImages.length - 1 
        ? this.currentImageIndex + 1 
        : 0;
    }
  }

  selectImage(index: number): void {
    this.currentImageIndex = index;
  }

  // Review methods
  submitReview(): void {
    if (!this.isLoggedIn) {
      Swal.fire({
        icon: 'warning',
        title: 'Login Required',
        text: 'Please log in to leave a review.',
        confirmButtonColor: '#08227B'
      });
      return;
    }

    if (this.reviewForm.invalid || !this.property) {
      return;
    }

    this.isSubmittingReview = true;
    const reviewData = {
      rating: this.reviewForm.value.rating,
      comment: this.reviewForm.value.comment
    };

    const reviewSub = this.propertyService.addReview(this.property.propertyId, reviewData).subscribe({
      next: (response) => {
        this.isSubmittingReview = false;
        Swal.fire({
          icon: 'success',
          title: 'Review Added',
          text: 'Your review has been added successfully!',
          showConfirmButton: false,
          timer: 1500
        });
        
        // Reset form and reload reviews
        this.reviewForm.reset({ rating: 5, comment: '' });
        this.loadReviews(this.property!.propertyId);
      },
      error: (error) => {
        this.isSubmittingReview = false;
        console.error('Error adding review:', error);
        Swal.fire({
          icon: 'error',
          title: 'Review Failed',
          text: 'Failed to add your review. Please try again.',
          confirmButtonColor: '#08227B'
        });
      }
    });
    this.subscriptions.push(reviewSub);
  }

  // Favorite methods
  toggleFavorite(): void {
    if (!this.isLoggedIn) {
      Swal.fire({
        icon: 'warning',
        title: 'Login Required',
        text: 'Please log in to add properties to favorites.',
        confirmButtonColor: '#08227B'
      });
      return;
    }

    if (!this.property) return;

    const action = this.property.isFavorite ? 'remove' : 'add';
    const apiCall = this.property.isFavorite 
      ? this.propertyService.removeFromFavorites(this.property.propertyId)
      : this.propertyService.addToFavorites(this.property.propertyId);

    const favSub = apiCall.subscribe({
      next: () => {
        this.property!.isFavorite = !this.property!.isFavorite;
        const message = this.property!.isFavorite ? 'Added to favorites' : 'Removed from favorites';
        Swal.fire({
          position: 'top-end',
          icon: 'success',
          title: message,
          showConfirmButton: false,
          timer: 1500
        });
      },
      error: (error) => {
        console.error('Error updating favorites:', error);
        Swal.fire({
          icon: 'error',
          title: 'Failed to update favorites',
          text: 'Please try again.',
          confirmButtonColor: '#08227B'
        });
      }
    });
    this.subscriptions.push(favSub);
  }

  // Contact owner
  contactOwner(): void {
    if (!this.property) return;

    const phoneNumber = this.property.ownerInfo.phoneNumber;
    const message = `Hello, I'm interested in your property: ${this.property.title}`;
    const whatsappUrl = `https://wa.me/${phoneNumber}?text=${encodeURIComponent(message)}`;
    
    window.open(whatsappUrl, '_blank');
  }

  // Helper methods
  getStarArray(rating: number): boolean[] {
    return Array(5).fill(false).map((_, i) => i < rating);
  }

  formatPrice(price: number): string {
    return new Intl.NumberFormat('en-EG', {
      style: 'currency',
      currency: 'EGP',
      minimumFractionDigits: 0
    }).format(price);
  }

  formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('en-EG', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  }

  goBack(): void {
    this.router.navigate(['/home']);
  }
}


================================================
File: app/reset-password/reset-password.component.css
================================================



================================================
File: app/reset-password/reset-password.component.html
================================================
<div class="container">
    <!-- Left side (Blue background with image) -->
    <div class="image-side">
      <div class="close-button">
        <button class="close-btn">âœ•</button>
      </div>
      <div class="image-container">
        <img src="../../assets/images/resetpassword.png" alt="Reset password illustration">
      </div>
    </div>
  
    <!-- Right side (Form inputs) -->
    <div class="form-side">
      <div class="form-container">
        <h1 class="title">Reset Password</h1>
        <p class="subtitle">Set your new password</p>
  
        <!-- Progress steps -->
        <div class="steps-container">
          <div class="step completed">
            <div class="step-number">1</div>
          </div>
          <div class="step-line completed"></div>
          <div class="step completed">
            <div class="step-number">2</div>
          </div>
          <div class="step-line completed"></div>
          <div class="step active">
            <div class="step-number">3</div>
          </div>
        </div>
  
        <form (ngSubmit)="onSubmit()" [formGroup]="resetForm">
          <!-- Password input -->
          <div class="form-group">
            <label for="password">New password</label>
            <div class="password-input">
              <input 
                [type]="showPassword ? 'text' : 'password'" 
                id="password"
                formControlName="password" 
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['password'].errors}"
              >
              <div class="toggle-password" (click)="togglePasswordVisibility()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                  <circle cx="12" cy="12" r="3"></circle>
                </svg>
              </div>
            </div>
            <div *ngIf="submitted && f['password'].errors" class="error-message">
              <div *ngIf="f['password'].errors['required']">Password is required</div>
              <div *ngIf="f['password'].errors['minlength']">Password must be at least 6 characters</div>
            </div>
          </div>
  
          <!-- Confirm password input -->
          <div class="form-group">
            <label for="confirmPassword">Confirm new password</label>
            <div class="password-input">
              <input 
                [type]="showConfirmPassword ? 'text' : 'password'" 
                id="confirmPassword"
                formControlName="confirmPassword" 
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['confirmPassword'].errors}"
              >
              <div class="toggle-password" (click)="toggleConfirmPasswordVisibility()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                  <circle cx="12" cy="12" r="3"></circle>
                </svg>
              </div>
            </div>
            <div *ngIf="submitted && f['confirmPassword'].errors" class="error-message">
              <div *ngIf="f['confirmPassword'].errors['required']">Confirm password is required</div>
              <div *ngIf="f['confirmPassword'].errors['matching']">Passwords must match</div>
            </div>
          </div>
          
          <!-- Submit button -->
          <button type="submit" class="reset-btn">Change Password</button>
        </form>
      </div>
    </div>
  </div>


================================================
File: app/reset-password/reset-password.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ResetPasswordComponent } from './reset-password.component';

describe('ResetPasswordComponent', () => {
  let component: ResetPasswordComponent;
  let fixture: ComponentFixture<ResetPasswordComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ResetPasswordComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(ResetPasswordComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/reset-password/reset-password.component.ts
================================================
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, AbstractControl, ValidationErrors } from '@angular/forms';
import { Router, ActivatedRoute, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import Swal from 'sweetalert2';
import { AuthService, ResetPasswordRequest } from '../services/auth.service';

@Component({
  selector: 'app-reset-password',
  templateUrl: './reset-password.component.html',
  styleUrls: ['./reset-password.component.css'],
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule]
})
export class ResetPasswordComponent implements OnInit {
  resetForm!: FormGroup;
  submitted = false;
  email: string = '';
  showPassword = false;
  showConfirmPassword = false;
  isLoading = false;
  isVerified = false;

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private route: ActivatedRoute,
    private authService: AuthService
  ) { }

  ngOnInit(): void {
    this.resetForm = this.formBuilder.group({
      password: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', Validators.required]
    }, {
      validators: this.passwordMatchValidator
    });

    // Get email and verification status from route parameters
    this.route.queryParams.subscribe(params => {
      this.email = params['email'] || params['contact'] || '';
      this.isVerified = params['verified'] === 'true';
      
      if (!this.email) {
        // No email provided, redirect to forgot password
        this.router.navigate(['/forget-pass']);
        return;
      }
      
      if (!this.isVerified) {
        // Email not verified, redirect to OTP verification
        this.router.navigate(['/otp-verification'], { 
          queryParams: { email: this.email } 
        });
      }
    });
  }

  // Custom validator for password matching
  passwordMatchValidator(control: AbstractControl): ValidationErrors | null {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');

    if (password && confirmPassword && password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ matching: true });
      return { matching: true };
    }
    return null;
  }

  // Getter for easy access to form fields
  get f() { return this.resetForm.controls; }

  togglePasswordVisibility(): void {
    this.showPassword = !this.showPassword;
  }

  toggleConfirmPasswordVisibility(): void {
    this.showConfirmPassword = !this.showConfirmPassword;
  }

  onSubmit(): void {
    this.submitted = true;

    // Stop if form is invalid
    if (this.resetForm.invalid) {
      return;
    }

    this.isLoading = true;

    // Prepare reset password request
    const resetRequest: ResetPasswordRequest = {
      email: this.email,
      newPassword: this.resetForm.value.password,
      confirmPassword: this.resetForm.value.confirmPassword
    };

    // Call reset password API
    this.authService.resetPassword(resetRequest).subscribe({
      next: (response) => {
        this.isLoading = false;
        
        if (response.status === 'Success') {
          Swal.fire({
            icon: 'success',
            title: 'Password Reset Successful',
            text: 'Your password has been reset successfully! You can now log in with your new password.',
            confirmButtonColor: '#08227B'
          }).then(() => {
            // Navigate to login page
            this.router.navigate(['/log-in']);
          });
        } else {
          Swal.fire({
            icon: 'error',
            title: 'Reset Failed',
            text: response.message || 'Failed to reset password. Please try again.',
            confirmButtonColor: '#08227B'
          });
        }
      },
      error: (error) => {
        this.isLoading = false;
        console.error('Reset password error:', error);
        
        let errorMessage = 'Failed to reset password. Please try again.';
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 400) {
          errorMessage = 'Invalid email or password format.';
        } else if (error.status === 404) {
          errorMessage = 'Email not found or verification expired.';
        }

        Swal.fire({
          icon: 'error',
          title: 'Reset Failed',
          text: errorMessage,
          confirmButtonColor: '#08227B'
        });
      }
    });
  }

  // Go back to OTP verification
  goBack(): void {
    this.router.navigate(['/otp-verification'], { 
      queryParams: { email: this.email } 
    });
  }

  // Go to login page
  goToLogin(): void {
    this.router.navigate(['/log-in']);
  }
}


================================================
File: app/services/amenities.service.ts
================================================
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { AuthService } from './auth.service';

export interface Amenity {
  amenityId: number;
  name: string;
}

export interface AmenityResponse {
  $values: Amenity[];
}

export interface CreateAmenityRequest {
  name: string;
}

export interface CreateAmenityResponse {
  id: number;
  name: string;
  properties: {
    $values: any[];
  };
}

export type AmenityType = 'internal' | 'external' | 'accessibility';

@Injectable({
  providedIn: 'root'
})
export class AmenitiesService {
  private apiUrl = 'http://digitalpropertyapi.runasp.net/api/Amenties';

  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) { }

  // Get internal amenities
  getInternalAmenities(): Observable<Amenity[]> {
    return this.http.get<AmenityResponse>(`${this.apiUrl}/internal`)
      .pipe(
        map(response => response.$values || []),
        catchError((error) => {
          console.error('Error fetching internal amenities:', error);
          throw error;
        })
      );
  }

  // Get external amenities
  getExternalAmenities(): Observable<Amenity[]> {
    return this.http.get<AmenityResponse>(`${this.apiUrl}/external`)
      .pipe(
        map(response => response.$values || []),
        catchError((error) => {
          console.error('Error fetching external amenities:', error);
          throw error;
        })
      );
  }

  // Get accessibility amenities
  getAccessibilityAmenities(): Observable<Amenity[]> {
    return this.http.get<AmenityResponse>(`${this.apiUrl}/accessibility`)
      .pipe(
        map(response => response.$values || []),
        catchError((error) => {
          console.error('Error fetching accessibility amenities:', error);
          throw error;
        })
      );
  }

  // Get all amenities by type
  getAmenitiesByType(type: AmenityType): Observable<Amenity[]> {
    switch (type) {
      case 'internal':
        return this.getInternalAmenities();
      case 'external':
        return this.getExternalAmenities();
      case 'accessibility':
        return this.getAccessibilityAmenities();
      default:
        throw new Error(`Invalid amenity type: ${type}`);
    }
  }

  // Create internal amenity
  createInternalAmenity(request: CreateAmenityRequest): Observable<CreateAmenityResponse> {
    return this.http.post<CreateAmenityResponse>(`${this.apiUrl}/internal`, request, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error creating internal amenity:', error);
        throw error;
      })
    );
  }

  // Create external amenity
  createExternalAmenity(request: CreateAmenityRequest): Observable<CreateAmenityResponse> {
    return this.http.post<CreateAmenityResponse>(`${this.apiUrl}/external`, request, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error creating external amenity:', error);
        throw error;
      })
    );
  }

  // Create accessibility amenity
  createAccessibilityAmenity(request: CreateAmenityRequest): Observable<CreateAmenityResponse> {
    return this.http.post<CreateAmenityResponse>(`${this.apiUrl}/accessibility`, request, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error creating accessibility amenity:', error);
        throw error;
      })
    );
  }

  // Create amenity by type
  createAmenityByType(type: AmenityType, request: CreateAmenityRequest): Observable<CreateAmenityResponse> {
    switch (type) {
      case 'internal':
        return this.createInternalAmenity(request);
      case 'external':
        return this.createExternalAmenity(request);
      case 'accessibility':
        return this.createAccessibilityAmenity(request);
      default:
        throw new Error(`Invalid amenity type: ${type}`);
    }
  }

  // Delete internal amenity
  deleteInternalAmenity(id: number): Observable<any> {
    return this.http.delete(`${this.apiUrl}/internal/${id}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error deleting internal amenity:', error);
        throw error;
      })
    );
  }

  // Delete external amenity
  deleteExternalAmenity(id: number): Observable<any> {
    return this.http.delete(`${this.apiUrl}/external/${id}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error deleting external amenity:', error);
        throw error;
      })
    );
  }

  // Delete accessibility amenity
  deleteAccessibilityAmenity(id: number): Observable<any> {
    return this.http.delete(`${this.apiUrl}/accessibility/${id}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error deleting accessibility amenity:', error);
        throw error;
      })
    );
  }

  // Delete amenity by type
  deleteAmenityByType(type: AmenityType, id: number): Observable<any> {
    switch (type) {
      case 'internal':
        return this.deleteInternalAmenity(id);
      case 'external':
        return this.deleteExternalAmenity(id);
      case 'accessibility':
        return this.deleteAccessibilityAmenity(id);
      default:
        throw new Error(`Invalid amenity type: ${type}`);
    }
  }

  // Helper method to get auth headers
  private getAuthHeaders(): HttpHeaders {
    return this.authService.getAuthHeaders();
  }

  // Get amenity type display name
  getAmenityTypeDisplayName(type: AmenityType): string {
    const displayNames = {
      'internal': 'Internal Amenities',
      'external': 'External Amenities',
      'accessibility': 'Accessibility Features'
    };
    return displayNames[type];
  }

  // Get amenity type display name in Arabic
  getAmenityTypeDisplayNameArabic(type: AmenityType): string {
    const displayNames = {
      'internal': 'المرافق الداخلية',
      'external': 'المرافق الخارجية',
      'accessibility': 'مميزات الوصول'
    };
    return displayNames[type];
  }
}


================================================
File: app/services/auth.service.ts
================================================
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { tap, catchError, map } from 'rxjs/operators';
import { CookieService } from 'ngx-cookie-service';

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  $id?: string;
  token: string;
  email: string;
  displayName: string;
  status?: string;
  message?: string;
}

export interface SignupRequest {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
  city: string;
  birthOfDate: string;
  password: string;
  confirmPassword: string;
  isTermsAccepted: boolean;
}

export interface SignupResponse {
  $id?: string;
  status: string;
  message: string;
  userId?: string;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ForgotPasswordResponse {
  $id?: string;
  status: string;
  message: string;
}

export interface VerifyOtpRequest {
  email: string;
  otp: string;
}

export interface VerifyOtpResponse {
  $id?: string;
  status: string;
  message: string;
}

export interface ResetPasswordRequest {
  email: string;
  newPassword: string;
  confirmPassword: string;
}

export interface ResetPasswordResponse {
  $id?: string;
  status: string;
  message: string;
}

export interface ResendOtpRequest {
  email: string;
}

export interface ResendOtpResponse {
  $id?: string;
  status: string;
  message: string;
}

export interface ResendEmailConfirmationOtpRequest {
  email: string;
}

export interface ResendEmailConfirmationOtpResponse {
  $id?: string;
  status: string;
  message: string;
}

export interface ChangePasswordRequest {
  oldPassword: string;
  newPassword: string;
  confirmNewPassword: string;
}

export interface UserProfile {
  userId: string;
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber?: string;
  city?: string;
  imageUrl?: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiUrl = 'http://digitalpropertyapi.runasp.net/api/Authentication';
  private userApiUrl = 'http://digitalpropertyapi.runasp.net/api/User';
  
  private currentUserSubject = new BehaviorSubject<any>(null);
  public currentUser$ = this.currentUserSubject.asObservable();

  constructor(
    private http: HttpClient,
    private cookieService: CookieService
  ) {
    const token = this.cookieService.get('token');
    if (token) {
      this.loadUserFromStorage();
    }
  }

  // Login method
  login(credentials: LoginRequest): Observable<LoginResponse> {
    const loginDto = {
      email: credentials.email,
      password: credentials.password
    };

    return this.http.post<LoginResponse>(`${this.apiUrl}/login`, loginDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      tap((response: LoginResponse) => {
        console.log('Login response:', response);
        
        if (response.status === 'Error') {
          throw new Error(response.message || 'Login failed');
        }
        
        if (response.token) {
          this.cookieService.set('token', response.token, 7);
          
          const nameParts = response.displayName?.split(' ') || ['User'];
          const userData = {
            email: response.email,
            firstName: nameParts[0] || 'User',
            lastName: nameParts.slice(1).join(' ') || '',
            displayName: response.displayName,
            token: response.token
          };
          
          localStorage.setItem('userData', JSON.stringify(userData));
          this.currentUserSubject.next(userData);
        }
      }),
      catchError((error) => {
        console.error('Login error:', error);
        
        let errorMessage = 'Login failed. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 500) {
          errorMessage = 'Server error. Please try again later.';
        } else if (error.status === 401) {
          errorMessage = 'Invalid email or password.';
        } else if (error.status === 404) {
          errorMessage = 'Login service is temporarily unavailable.';
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Sign up method
  signup(userData: SignupRequest): Observable<SignupResponse> {
    const userDto = {
      firstName: userData.firstName,
      lastName: userData.lastName,
      email: userData.email,
      phoneNumber: userData.phoneNumber,
      city: userData.city,
      birthOfDate: userData.birthOfDate,
      password: userData.password,
      confirmPassword: userData.confirmPassword,
      isTermsAccepted: userData.isTermsAccepted
    };

    return this.http.post<SignupResponse>(`${this.apiUrl}/signup`, userDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      tap((response) => {
        console.log('Signup response:', response);
        
        if (response.status === 'Error') {
          throw new Error(response.message || 'Signup failed');
        }
      }),
      catchError((error) => {
        console.error('Signup error:', error);
        
        let errorMessage = 'Registration failed. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 500) {
          errorMessage = 'Server error. Please try again later.';
        } else if (error.status === 409) {
          errorMessage = 'An account with this email already exists.';
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Forgot password method
  forgotPassword(request: ForgotPasswordRequest): Observable<ForgotPasswordResponse> {
    const emailDto = { email: request.email };
    
    console.log('Sending forgot password request:', emailDto);
    
    return this.http.post<ForgotPasswordResponse>(`${this.apiUrl}/forgot-password`, emailDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      tap((response) => {
        console.log('Forgot password raw response:', response);
      }),
      map((response: any) => {
        return {
          status: response.status || 'Success',
          message: response.message || 'OTP sent successfully for password reset.'
        } as ForgotPasswordResponse;
      }),
      catchError((error) => {
        console.error('Forgot password error:', error);
        let errorMessage = 'Failed to send reset email. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 404) {
          errorMessage = 'Email not found. Please check your email address.';
        } else if (error.status === 400) {
          errorMessage = 'Invalid email format.';
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Verify OTP method
  verifyOtp(request: VerifyOtpRequest): Observable<VerifyOtpResponse> {
    const otpDto = {
      email: request.email,
      otp: request.otp
    };
    
    return this.http.post<VerifyOtpResponse>(`${this.apiUrl}/verify-otp`, otpDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      map((response: any) => {
        return {
          status: response.status || 'Success',
          message: response.message || 'OTP verified successfully.'
        } as VerifyOtpResponse;
      }),
      catchError((error) => {
        console.error('Verify OTP error:', error);
        let errorMessage = 'Invalid OTP. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Reset password method
  resetPassword(request: ResetPasswordRequest): Observable<ResetPasswordResponse> {
    const resetDto = {
      email: request.email,
      newPassword: request.newPassword,
      confirmPassword: request.confirmPassword
    };
    
    return this.http.post<ResetPasswordResponse>(`${this.apiUrl}/reset-password`, resetDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      map((response: any) => {
        return {
          status: response.status || 'Success',
          message: response.message || 'Password reset successfully.'
        } as ResetPasswordResponse;
      }),
      catchError((error) => {
        console.error('Reset password error:', error);
        let errorMessage = 'Failed to reset password. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Resend OTP for forgot password
  resendOtp(request: ResendOtpRequest): Observable<ResendOtpResponse> {
    const emailDto = { email: request.email };
    
    return this.http.post<ResendOtpResponse>(`${this.apiUrl}/resend-otp`, emailDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      map((response: any) => {
        return {
          status: response.status || 'Success',
          message: response.message || 'OTP resent successfully.'
        } as ResendOtpResponse;
      }),
      catchError((error) => {
        console.error('Resend OTP error:', error);
        let errorMessage = 'Failed to resend OTP. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Resend email confirmation OTP for signup verification
  resendEmailConfirmationOtp(request: ResendEmailConfirmationOtpRequest): Observable<ResendEmailConfirmationOtpResponse> {
    const emailDto = { email: request.email };
    
    return this.http.post<ResendEmailConfirmationOtpResponse>(`${this.apiUrl}/resend-email-confirmation-otp`, emailDto, {
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        'Accept': '*/*'
      })
    }).pipe(
      map((response: any) => {
        return {
          status: response.status || 'Success',
          message: response.message || 'Email confirmation OTP resent successfully.'
        } as ResendEmailConfirmationOtpResponse;
      }),
      catchError((error) => {
        console.error('Resend email confirmation OTP error:', error);
        let errorMessage = 'Failed to resend confirmation OTP. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Change password method
  changePassword(request: ChangePasswordRequest): Observable<any> {
    const changePasswordDto = {
      oldPassword: request.oldPassword,
      newPassword: request.newPassword,
      confirmNewPassword: request.confirmNewPassword
    };
    
    return this.http.put(`${this.userApiUrl}/ChangePassword`, changePasswordDto, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Change password error:', error);
        let errorMessage = 'Failed to change password. Please try again.';
        
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 400) {
          errorMessage = 'Current password is incorrect.';
        }
        
        throw new Error(errorMessage);
      })
    );
  }

  // Get user profile
  getUserProfile(): Observable<UserProfile> {
    return this.http.get<UserProfile>(`${this.userApiUrl}/GetUser`, {
      headers: this.getAuthHeaders()
    }).pipe(
      tap((profile) => {
        const userData = {
          userId: profile.userId,
          email: profile.email,
          firstName: profile.firstName,
          lastName: profile.lastName,
          phoneNumber: profile.phoneNumber,
          city: profile.city,
          imageUrl: profile.imageUrl
        };
        localStorage.setItem('userData', JSON.stringify(userData));
        this.currentUserSubject.next(userData);
      }),
      catchError((error) => {
        console.error('Get user profile error:', error);
        throw error;
      })
    );
  }

  // Update user profile
  updateUserProfile(formData: FormData): Observable<any> {
    return this.http.put(`${this.userApiUrl}/Update`, formData, {
      headers: new HttpHeaders({
        'Authorization': `Bearer ${this.getToken()}`
      })
    }).pipe(
      tap((response) => {
        this.getUserProfile().subscribe();
      }),
      catchError((error) => {
        console.error('Update user profile error:', error);
        throw error;
      })
    );
  }

  // Logout method
  logout(): void {
    this.cookieService.delete('token');
    this.cookieService.delete('userId');
    localStorage.removeItem('userData');
    this.currentUserSubject.next(null);
  }

  // Get current user
  getCurrentUser(): any {
    return this.currentUserSubject.value;
  }

  // Check if user is logged in
  isLoggedIn(): boolean {
    return !!this.cookieService.get('token');
  }

  // Get auth headers for authenticated requests
  getAuthHeaders(): HttpHeaders {
    const token = this.getToken();
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }

  // Get token
  private getToken(): string {
    return this.cookieService.get('token') || '';
  }

  // Load user data from storage
  private loadUserFromStorage(): void {
    const userDataString = localStorage.getItem('userData');
    if (userDataString) {
      try {
        const userData = JSON.parse(userDataString);
        this.currentUserSubject.next(userData);
      } catch (error) {
        console.error('Error parsing user data from localStorage:', error);
        localStorage.removeItem('userData');
        this.logout();
      }
    }
  }

  // Get user data from localStorage
  getUserData(): any {
    const userDataString = localStorage.getItem('userData');
    if (userDataString) {
      try {
        return JSON.parse(userDataString);
      } catch (error) {
        console.error('Error parsing user data:', error);
        return null;
      }
    }
    return null;
  }

  // Get user image URL
  getUserImageUrl(): string {
    const userData = this.getUserData();
    return userData?.imageUrl || 'assets/images/profile.jpeg';
  }

  // Get user full name
  getUserFullName(): string {
    const userData = this.getUserData();
    if (userData) {
      if (userData.displayName) {
        return userData.displayName;
      }
      return `${userData.firstName || ''} ${userData.lastName || ''}`.trim();
    }
    return 'Guest';
  }
}


================================================
File: app/services/payment.service.ts
================================================
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service';

export interface PaymentIntentRequest {
  currency: string;
  amount?: number; // سنت (مثال: 5000 = $50.00)
}

export interface PaymentIntentResponse {
  clientSecret: string;
  paymentIntentId: string;
}

@Injectable({
  providedIn: 'root'
})
export class PaymentService {
  private apiUrl = 'http://digitalpropertyapi.runasp.net/api/Payment';

  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) { }

  createPaymentIntent(request: PaymentIntentRequest): Observable<PaymentIntentResponse> {
    // 🚨 TEMPORARY: Mock response for testing
    // احذف الكومنت لما الـ API يشتغل
    /*
    return of({
      clientSecret: 'pi_mock_1234567890_secret_test',
      paymentIntentId: 'pi_mock_1234567890'
    }).pipe(delay(1000));
    */
    
    // الـ API الحقيقي
    return this.http.post<PaymentIntentResponse>(
      `${this.apiUrl}/create-or-update-payment-intent`,
      {
        currency: request.currency,
        amount: request.amount || 0 // $50.00 in cents
      },
      {
        headers: this.authService.getAuthHeaders()
      }
    );
  }
}


================================================
File: app/services/property.service.ts
================================================
import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { delay, tap, map, catchError } from 'rxjs/operators';
import { AuthService } from './auth.service';

export interface PropertyResponse {
  $id?: string;
  pageIndex: number;
  pageSize: number;
  totalCount: number;
  data: {
    $id?: string;
    $values: Property[];
  };
}

export interface Property {
  propertyId: number;
  title: string;
  description: string;
  price: number;
  propertyType: string;
  size: number;
  bedrooms: number;
  bathrooms: number;
  street: string;
  city: string;
  governate: string;
  listedAt: string;
  propertyImages: string[];
  ownerInfo: OwnerInfo;
  internalAmenities: string[];
  externalAmenities: string[];
  accessibilityAmenities: string[];
  isFavorite?: boolean;
}

export interface OwnerInfo {
  $id?: string;
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
}

export interface PropertyFilters {
  pageIndex?: number;
  pageSize?: number;
  propertyType?: string;
  city?: string;
  governate?: string;
  minPrice?: number;
  maxPrice?: number;
  minBedrooms?: number;
  maxBedrooms?: number;
  bedrooms?: number;
  bathrooms?: number;
  size?: number;
  sortBy?: string;
  searchTerm?: string;
  internalAmenityIds?: number[];
  externalAmenityIds?: number[];
  accessibilityAmenityIds?: number[];
  userId?: number;
}

export interface Review {
  reviewId?: number;
  propertyId: number;
  userId?: string;
  userName?: string;
  rating: number;
  comment: string;
  reviewDate?: string;
}

export interface FavoriteProperty {
  $id?: string;
  propertyId: number;
  title: string;
  mainImageUrl: string;
  city: string;
  governate: string;
  price: number;
  listingType: string;
  addedToFavoritesAt: string;
}

export interface FavoritesResponse {
  $id?: string;
  $values: FavoriteProperty[];
}

@Injectable({
  providedIn: 'root'
})
export class PropertyService {
  private apiUrl = 'http://digitalpropertyapi.runasp.net/api';

  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) { }

  // Get all properties with pagination and filters
  getProperties(filters?: PropertyFilters): Observable<{ pageIndex: number; pageSize: number; totalCount: number; data: Property[] }> {
    let params = new HttpParams();
    
    // Set default pagination if not provided
    const pageSize = filters?.pageSize || 12;
    const pageIndex = filters?.pageIndex || 1;
    
    params = params.set('PageSize', pageSize.toString());
    params = params.set('PageIndex', pageIndex.toString());
    
    if (filters) {
      if (filters.propertyType) params = params.set('PropertyType', filters.propertyType);
      if (filters.city) params = params.set('City', filters.city);
      if (filters.governate) params = params.set('Governate', filters.governate);
      if (filters.bedrooms) params = params.set('Bedrooms', filters.bedrooms.toString());
      if (filters.bathrooms) params = params.set('Bathrooms', filters.bathrooms.toString());
      if (filters.size) params = params.set('Size', filters.size.toString());
      if (filters.minPrice) params = params.set('MinPrice', filters.minPrice.toString());
      if (filters.maxPrice) params = params.set('MaxPrice', filters.maxPrice.toString());
      if (filters.sortBy) params = params.set('SortBy', filters.sortBy);
      if (filters.userId) params = params.set('UserId', filters.userId.toString());
      
      if (filters.internalAmenityIds) {
        filters.internalAmenityIds.forEach(id => {
          params = params.append('InternalAmenityIds', id.toString());
        });
      }
      if (filters.externalAmenityIds) {
        filters.externalAmenityIds.forEach(id => {
          params = params.append('ExternalAmenityIds', id.toString());
        });
      }
      if (filters.accessibilityAmenityIds) {
        filters.accessibilityAmenityIds.forEach(id => {
          params = params.append('AccessibilityAmenityIds', id.toString());
        });
      }
    }

    console.log('🔍 Fetching properties with params:', params.toString());

    return this.http.get<PropertyResponse>(`${this.apiUrl}/Properties/GetAll`, { 
      params,
      headers: new HttpHeaders({
        'Accept': '*/*'
      })
    }).pipe(
      tap((response) => {
        console.log('✅ Properties API raw response:', response);
      }),
      map((response: PropertyResponse) => {
        // Handle the response structure with $id and $values
        const properties = response.data?.$values || [];
        const formattedProperties = properties.map(property => this.formatProperty(property));
        
        console.log('✅ Formatted properties:', formattedProperties);
        
        return {
          pageIndex: response.pageIndex,
          pageSize: response.pageSize,
          totalCount: response.totalCount,
          data: formattedProperties
        };
      }),
      catchError((error) => {
        console.error('❌ Error loading properties:', error);
        // Return mock data if API fails
        return this.getMockProperties(filters);
      })
    );
  }

  // Get property by ID
  getPropertyById(id: number): Observable<Property> {
    return this.http.get<any>(`${this.apiUrl}/Properties/GetById/${id}`, {
      headers: new HttpHeaders({
        'Accept': '*/*'
      })
    }).pipe(
      map(property => this.formatProperty(property)),
      catchError((error) => {
        console.error('Error loading property:', error);
        return this.getMockPropertyById(id);
      })
    );
  }

  // Add new property
  addProperty(propertyData: FormData): Observable<any> {
    return this.http.post(`${this.apiUrl}/Properties/Create`, propertyData, {
      headers: new HttpHeaders({
        'Authorization': `Bearer ${this.getToken()}`
      })
    }).pipe(
      catchError((error) => {
        console.error('Error adding property:', error);
        
        let errorMessage = 'Failed to add property. Please try again.';
        if (error.error && error.error.message) {
          errorMessage = error.error.message;
        } else if (error.status === 401) {
          errorMessage = 'You must be logged in to add a property.';
        } else if (error.status === 500) {
          errorMessage = 'Server error. Please try again later.';
        }
        
        return throwError(() => ({
          status: error.status,
          error: { message: errorMessage }
        }));
      })
    );
  }

  // Update property
  updateProperty(id: number, propertyData: any): Observable<any> {
    return this.http.put(`${this.apiUrl}/Properties/Update/${id}`, propertyData, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error updating property:', error);
        throw error;
      })
    );
  }

  // Delete property
  deleteProperty(id: number): Observable<any> {
    return this.http.delete(`${this.apiUrl}/Properties/Delete/${id}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error deleting property:', error);
        throw error;
      })
    );
  }

 addToFavorites(propertyId: number): Observable<any> {
    console.log('Adding property to favorites:', propertyId);
    
    return this.http.post(`${this.apiUrl}/Favorites/${propertyId}`, {}, {
      headers: this.getAuthHeaders(),
      responseType: 'text' // Handle text response instead of JSON
    }).pipe(
      tap((response) => {
        console.log('Add to favorites response:', response);
      }),
      catchError((error) => {
        console.error('Error adding to favorites:', error);
        
        // Sometimes Angular treats successful text responses as errors
        if (error.status === 200 || (error.error && typeof error.error === 'string' && error.error.includes('added'))) {
          console.log('Actually successful - treating as success');
          return of('Property added to favorites.'); // Return success
        }
        
        throw error;
      })
    );
  }

  removeFromFavorites(propertyId: number): Observable<any> {
    console.log('Removing property from favorites:', propertyId);
    
    return this.http.delete(`${this.apiUrl}/Favorites/remove/${propertyId}`, {
      headers: this.getAuthHeaders(),
      responseType: 'text' // Handle text response instead of JSON
    }).pipe(
      tap((response) => {
        console.log('Remove from favorites response:', response);
      }),
      catchError((error) => {
        console.error('Error removing from favorites:', error);
        
        // Sometimes Angular treats successful text responses as errors
        if (error.status === 200 || (error.error && typeof error.error === 'string' && error.error.includes('removed'))) {
          console.log('Actually successful - treating as success');
          return of('Property removed from favorites.'); // Return success
        }
        
        throw error;
      })
    );
  }

  // Check if property is in favorites
  isPropertyInFavorites(propertyId: number): Observable<boolean> {
    return this.http.get<boolean>(`${this.apiUrl}/Favorites/added/${propertyId}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      tap((response) => {
        console.log(`✅ Property ${propertyId} is in favorites:`, response);
      }),
      catchError((error) => {
        console.error('❌ Error checking favorites:', error);
        return of(false);
      })
    );
  }

  // Get user favorites - FIXED to handle correct response structure
  getFavorites(): Observable<Property[]> {
    return this.http.get<FavoritesResponse>(`${this.apiUrl}/Favorites`, {
      headers: this.getAuthHeaders()
    }).pipe(
      tap((response) => {
        console.log('✅ Favorites API raw response:', response);
      }),
      map((response: FavoritesResponse) => {
        // Handle the response structure with $values
        const favorites = response.$values || [];
        return favorites.map(fav => this.formatFavoriteToProperty(fav));
      }),
      catchError((error) => {
        console.error('❌ Error loading favorites:', error);
        return of([]);
      })
    );
  }

  // Reviews management
  getPropertyReviews(propertyId: number): Observable<Review[]> {
    return this.http.get<Review[]>(`${this.apiUrl}/Reviews/property/${propertyId}`, {
      headers: new HttpHeaders({
        'Accept': '*/*'
      })
    }).pipe(
      catchError((error) => {
        console.error('Error loading reviews:', error);
        return of([]);
      })
    );
  }

  addReview(propertyId: number, review: { rating: number; comment: string }): Observable<any> {
    const userData = this.authService.getUserData();
    const userId = userData?.userId || '1';
    
    const reviewDto = {
      rating: review.rating,
      comment: review.comment
    };
    
    return this.http.post(`${this.apiUrl}/Reviews/${userId}/${propertyId}`, reviewDto, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error adding review:', error);
        throw error;
      })
    );
  }

  updateReview(propertyId: number, reviewId: number, review: { rating: number; comment: string }): Observable<any> {
    const userData = this.authService.getUserData();
    const userId = userData?.userId || '1';
    
    const reviewDto = {
      rating: review.rating,
      comment: review.comment
    };
    
    return this.http.put(`${this.apiUrl}/Reviews/${userId}/${reviewId}`, reviewDto, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error updating review:', error);
        throw error;
      })
    );
  }

  deleteReview(propertyId: number, reviewId: number): Observable<any> {
    const userData = this.authService.getUserData();
    const userId = userData?.userId || '1';
    
    return this.http.delete(`${this.apiUrl}/Reviews/${userId}/${reviewId}`, {
      headers: this.getAuthHeaders()
    }).pipe(
      catchError((error) => {
        console.error('Error deleting review:', error);
        throw error;
      })
    );
  }

  // Helper methods
  private getAuthHeaders(): HttpHeaders {
    const token = this.getToken();
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
      'Accept': '*/*'
    });
  }

  private getToken(): string {
    return this.authService.getAuthHeaders().get('Authorization')?.replace('Bearer ', '') || '';
  }

  // Format property data for display - FIXED to handle API response structure
  formatProperty(property: any): Property {
    return {
      propertyId: property.propertyId || property.id,
      title: property.title || 'Property Title',
      description: property.description || 'No description available',
      price: property.price || 0,
      propertyType: property.propertyType || 'Unknown',
      size: property.size || 0,
      bedrooms: property.bedrooms || 0,
      bathrooms: property.bathrooms || 0,
      street: property.street || '',
      city: property.city || '',
      governate: property.governate || '',
      listedAt: property.listedAt || property.createdAt || new Date().toISOString(),
      propertyImages: property.propertyImages?.$values || property.propertyImages || [],
      ownerInfo: property.ownerInfo || {
        firstName: 'Owner',
        lastName: 'Name',
        email: 'owner@email.com',
        phoneNumber: '+201234567890'
      },
      internalAmenities: property.internalAmenities?.$values || property.internalAmenities || [],
      externalAmenities: property.externalAmenities?.$values || property.externalAmenities || [],
      accessibilityAmenities: property.accessibilityAmenities?.$values || property.accessibilityAmenities || [],
      isFavorite: false // Will be set separately
    };
  }

  // Convert favorite response to property format
  private formatFavoriteToProperty(favorite: FavoriteProperty): Property {
    return {
      propertyId: favorite.propertyId,
      title: favorite.title,
      description: 'Favorite property',
      price: favorite.price,
      propertyType: favorite.listingType || 'Property',
      size: 0,
      bedrooms: 0,
      bathrooms: 0,
      street: '',
      city: favorite.city,
      governate: favorite.governate,
      listedAt: favorite.addedToFavoritesAt,
      propertyImages: [favorite.mainImageUrl],
      ownerInfo: {
        firstName: 'Owner',
        lastName: 'Name',
        email: 'owner@email.com',
        phoneNumber: '+201234567890'
      },
      internalAmenities: [],
      externalAmenities: [],
      accessibilityAmenities: [],
      isFavorite: true
    };
  }

  // Search properties
  searchProperties(searchTerm: string, filters?: PropertyFilters): Observable<{ pageIndex: number; pageSize: number; totalCount: number; data: Property[] }> {
    const searchFilters = {
      ...filters,
      searchTerm: searchTerm,
      pageIndex: 1,
      pageSize: 20
    };
    return this.getProperties(searchFilters);
  }

  // Mock fallback methods
  private getMockProperties(filters?: PropertyFilters): Observable<{ pageIndex: number; pageSize: number; totalCount: number; data: Property[] }> {
    const mockProperties = [
      {
        propertyId: 1,
        title: 'Modern Apartment in New Cairo',
        description: 'Beautiful 3-bedroom apartment with modern amenities.',
        price: 2500000,
        propertyType: 'Apartment',
        size: 180,
        bedrooms: 3,
        bathrooms: 2,
        street: '90th Street',
        city: 'Cairo',
        governate: 'Cairo',
        listedAt: '2024-01-15T00:00:00Z',
        propertyImages: ['assets/images/apartment.avif'],
        ownerInfo: {
          firstName: 'Ahmed',
          lastName: 'Hassan',
          email: 'ahmed.hassan@email.com',
          phoneNumber: '+201234567890'
        },
        internalAmenities: ['Air Conditioning', 'Furnished'],
        externalAmenities: ['Parking', 'Security'],
        accessibilityAmenities: ['Wheelchair Access'],
        isFavorite: false
      }
    ];

    return of({
      pageIndex: 1,
      pageSize: 12,
      totalCount: 1,
      data: mockProperties
    }).pipe(delay(1000));
  }

  private getMockPropertyById(id: number): Observable<Property> {
    const mockProperty = {
      propertyId: id,
      title: 'Modern Apartment in New Cairo',
      description: 'Beautiful 3-bedroom apartment with modern amenities.',
      price: 2500000,
      propertyType: 'Apartment',
      size: 180,
      bedrooms: 3,
      bathrooms: 2,
      street: '90th Street',
      city: 'Cairo',
      governate: 'Cairo',
      listedAt: '2024-01-15T00:00:00Z',
      propertyImages: ['assets/images/apartment.avif'],
      ownerInfo: {
        firstName: 'Ahmed',
        lastName: 'Hassan',
        email: 'ahmed.hassan@email.com',
        phoneNumber: '+201234567890'
      },
      internalAmenities: ['Air Conditioning', 'Furnished'],
      externalAmenities: ['Parking', 'Security'],
      accessibilityAmenities: ['Wheelchair Access'],
      isFavorite: false
    };

    return of(mockProperty).pipe(delay(500));
  }
}


================================================
File: app/sign-up/sign-up.component.css
================================================



================================================
File: app/sign-up/sign-up.component.html
================================================
<!-- Signup Component HTML with loading states -->
<div class="container">
    <!-- Left side (Form inputs) -->
    <div class="form-side">
      <div class="form-container">
        <h1 class="title">Sign Up</h1>
  
        <form (ngSubmit)="onSubmit()" [formGroup]="signupForm">
          <!-- Name inputs in a row -->
          <div class="form-row">
            <div class="form-group half">
              <label for="firstName">First Name</label>
              <input 
                type="text" 
                id="firstName"
                formControlName="firstName" 
                placeholder="ex: Ahmed"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['firstName'].errors}"
                [disabled]="isLoading"
              >
              <div *ngIf="submitted && f['firstName'].errors" class="error-message">
                <div *ngIf="f['firstName'].errors['required']">First name is required</div>
                <div *ngIf="f['firstName'].errors['minlength']">First name must be at least 2 characters</div>
              </div>
            </div>
  
            <div class="form-group half">
              <label for="lastName">Last Name</label>
              <input 
                type="text" 
                id="lastName"
                formControlName="lastName" 
                placeholder="ex: Wagdy"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['lastName'].errors}"
                [disabled]="isLoading"
              >
              <div *ngIf="submitted && f['lastName'].errors" class="error-message">
                <div *ngIf="f['lastName'].errors['required']">Last name is required</div>
                <div *ngIf="f['lastName'].errors['minlength']">Last name must be at least 2 characters</div>
              </div>
            </div>
          </div>
  
          <!-- Email input -->
          <div class="form-group">
            <label for="email">Email</label>
            <input 
              type="email" 
              id="email"
              formControlName="email" 
              placeholder="ex: ahmedwagdy@email.com"
              class="form-control"
              [ngClass]="{'invalid': submitted && f['email'].errors}"
              [disabled]="isLoading"
            >
            <div *ngIf="submitted && f['email'].errors" class="error-message">
              <div *ngIf="f['email'].errors['required']">Email is required</div>
              <div *ngIf="f['email'].errors['email']">Enter a valid email</div>
            </div>
          </div>
  
          <!-- Phone number with country code -->
          <div class="form-group">
            <label for="phone">Phone Number</label>
            <div class="phone-input">
              <div class="country-code">
                <select formControlName="countryCode" class="code-select" [disabled]="isLoading">
                  <option value="+20">+20</option>
                  <option value="+1">+1</option>
                  <option value="+44">+44</option>
                  <option value="+33">+33</option>
                  <option value="+49">+49</option>
                </select>
              </div>
              <input 
                type="tel" 
                id="phone"
                formControlName="phone" 
                placeholder="ex: 1007559638"
                class="form-control phone"
                [ngClass]="{'invalid': submitted && f['phone'].errors}"
                [disabled]="isLoading"
              >
            </div>
            <div *ngIf="submitted && f['phone'].errors" class="error-message">
              <div *ngIf="f['phone'].errors['required']">Phone number is required</div>
              <div *ngIf="f['phone'].errors['pattern']">Enter a valid phone number (10-11 digits)</div>
            </div>
          </div>
  
          <!-- City dropdown -->
          <div class="form-group">
            <label for="city">City</label>
            <div class="dropdown">
              <select formControlName="city" id="city" class="form-control" [disabled]="isLoading">
                <option value="" disabled selected>ex: Cairo</option>
                <option value="Cairo">Cairo</option>
                <option value="Alexandria">Alexandria</option>
                <option value="Giza">Giza</option>
                <option value="Luxor">Luxor</option>
                <option value="Aswan">Aswan</option>
                <option value="Sharm El Sheikh">Sharm El Sheikh</option>
                <option value="Hurghada">Hurghada</option>
              </select>
            </div>
            <div *ngIf="submitted && f['city'].errors" class="error-message">
              <div *ngIf="f['city'].errors['required']">City is required</div>
            </div>
          </div>
  
          <!-- Date of birth -->
          <!-- Date of birth -->
          <div class="form-group">
            <label for="dob">Birth of date</label>
            <div class="date-input">
              <input 
                type="date" 
                id="dob"
                formControlName="dob" 
                class="form-control"
                [ngClass]="{'invalid': submitted && f['dob'].errors}"
                [disabled]="isLoading"
              >
              <div class="calendar-icon">
                <i class="bi bi-calendar"></i>
              </div>
            </div>
            <div *ngIf="submitted && f['dob'].errors" class="error-message">
              <div *ngIf="f['dob'].errors['required']">Date of birth is required</div>
            </div>
          </div>
  
          <!-- Password input -->
          <div class="form-group">
            <label for="password">Password</label>
            <div class="password-input">
              <input 
                [type]="showPassword ? 'text' : 'password'" 
                id="password"
                formControlName="password" 
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['password'].errors}"
                [disabled]="isLoading"
              >
              <div class="toggle-password" (click)="togglePasswordVisibility()" *ngIf="!isLoading">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path *ngIf="!showPassword" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                  <path *ngIf="showPassword" d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                  <circle *ngIf="!showPassword" cx="12" cy="12" r="3"></circle>
                  <line *ngIf="showPassword" x1="1" y1="1" x2="23" y2="23"></line>
                </svg>
              </div>
            </div>
            <div *ngIf="submitted && f['password'].errors" class="error-message">
              <div *ngIf="f['password'].errors['required']">Password is required</div>
              <div *ngIf="f['password'].errors['minlength']">Password must be at least 6 characters</div>
            </div>
          </div>
  
          <!-- Confirm password input -->
          <div class="form-group">
            <label for="confirmPassword">Confirm password</label>
            <div class="password-input">
              <input 
                [type]="showConfirmPassword ? 'text' : 'password'" 
                id="confirmPassword"
                formControlName="confirmPassword" 
                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢"
                class="form-control"
                [ngClass]="{'invalid': submitted && f['confirmPassword'].errors}"
                [disabled]="isLoading"
              >
              <div class="toggle-password" (click)="toggleConfirmPasswordVisibility()" *ngIf="!isLoading">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path *ngIf="!showConfirmPassword" d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                  <path *ngIf="showConfirmPassword" d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path>
                  <circle *ngIf="!showConfirmPassword" cx="12" cy="12" r="3"></circle>
                  <line *ngIf="showConfirmPassword" x1="1" y1="1" x2="23" y2="23"></line>
                </svg>
              </div>
            </div>
            <div *ngIf="submitted && f['confirmPassword'].errors" class="error-message">
              <div *ngIf="f['confirmPassword'].errors['required']">Confirm password is required</div>
              <div *ngIf="f['confirmPassword'].errors['matching']">Passwords must match</div>
            </div>
          </div>
  
          <!-- Terms checkbox -->
          <div class="form-group terms-group">
            <div class="checkbox-container">
              <input 
                type="checkbox" 
                id="terms"
                formControlName="terms" 
                class="checkbox"
                [disabled]="isLoading"
              >
              <label for="terms" class="terms-label">I understood the <span class="terms-link">terms & policy</span>.</label>
            </div>
            <div *ngIf="submitted && f['terms'].errors" class="error-message">
              <div *ngIf="f['terms'].errors['required']">You must accept the terms and policy</div>
            </div>
          </div>
          
          <!-- Sign up button -->
          <button type="submit" class="signup-btn" [disabled]="isLoading">
            <span *ngIf="!isLoading">Sign up</span>
            <span *ngIf="isLoading">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="animate-spin">
                <line x1="12" y1="2" x2="12" y2="6"></line>
                <line x1="12" y1="18" x2="12" y2="22"></line>
                <line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line>
                <line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line>
                <line x1="2" y1="12" x2="6" y2="12"></line>
                <line x1="18" y1="12" x2="22" y2="12"></line>
                <line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line>
                <line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>
              </svg>
              Creating account...
            </span>
          </button>
        </form>
  
        <!-- Google sign up -->
        <div class="google-signup">
          <button class="google-btn" (click)="signupWithGoogle()" [disabled]="isLoading">
            <img src="../../assets/images/google.png" alt="Google">
            Sign up with Google
          </button>
        </div>
  
        <!-- Login link -->
        <div class="login-link">
          <span>Do you have an account?</span>
          <a [routerLink]="['/log-in']" *ngIf="!isLoading">Login</a>
        </div>
      </div>
    </div>
  
    <!-- Right side (Blue background with image) -->
    <div class="image-side">
      <div class="close-button">
        <button class="close-btn" (click)="goToHome()">âœ•</button>
      </div>
      <div class="image-container">
        <img src="../../assets/images/signup.png" alt="Sign up illustration">
      </div>
    </div>
  </div>
  
  <!-- Add CSS for loading animation -->
  <style>
    .animate-spin {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    
    .signup-btn:disabled,
    .google-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .form-control:disabled,
    .code-select:disabled,
    .checkbox:disabled {
      background-color: #f5f5f5;
      opacity: 0.6;
    }
  </style>


================================================
File: app/sign-up/sign-up.component.spec.ts
================================================
import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SignUpComponent } from './sign-up.component';

describe('SignUpComponent', () => {
  let component: SignUpComponent;
  let fixture: ComponentFixture<SignUpComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SignUpComponent]
    })
    .compileComponents();
    
    fixture = TestBed.createComponent(SignUpComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



================================================
File: app/sign-up/sign-up.component.ts
================================================
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule, AbstractControl, ValidationErrors } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import Swal from 'sweetalert2';
import { AuthService, SignupRequest } from '../services/auth.service';

@Component({
  selector: 'app-sign-up',
  templateUrl: './sign-up.component.html',
  styleUrls: ['./sign-up.component.css'],
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, RouterModule]
})
export class SignUpComponent implements OnInit {
  signupForm!: FormGroup;
  submitted = false;
  showPassword = false;
  showConfirmPassword = false;
  isLoading = false;

  constructor(
    private formBuilder: FormBuilder,
    private router: Router,
    private authService: AuthService
  ) { }

  ngOnInit(): void {
    // Check if user is already logged in
    if (this.authService.isLoggedIn()) {
      // User is already logged in, redirect to home
      this.router.navigate(['/home']);
      return;
    }
    
    this.signupForm = this.formBuilder.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]],
      countryCode: ['+20', Validators.required],
      phone: ['', [Validators.required, Validators.pattern('^[0-9]{10,11}$')]],
      city: ['', Validators.required],
      dob: ['', Validators.required],
      password: ['', [Validators.required, Validators.minLength(6)]],
      confirmPassword: ['', Validators.required],
      terms: [false, Validators.requiredTrue]
    }, {
      validators: this.passwordMatchValidator
    });
  }

  // Getter for easy access to form fields
  get f() { return this.signupForm.controls; }

  // Custom validator for password matching
  passwordMatchValidator(control: AbstractControl): ValidationErrors | null {
    const password = control.get('password');
    const confirmPassword = control.get('confirmPassword');

    if (password && confirmPassword && password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ matching: true });
      return { matching: true };
    }
    return null;
  }

  onSubmit(): void {
    this.submitted = true;

    // Stop if form is invalid
    if (this.signupForm.invalid) {
      // Find and focus on the first invalid field
      const firstInvalidField = Object.keys(this.signupForm.controls).find(
        key => this.signupForm.get(key)?.invalid
      );
      
      if (firstInvalidField) {
        const element = document.getElementById(firstInvalidField);
        if (element) {
          element.focus();
          element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
      return;
    }

    this.isLoading = true;

    // Prepare signup request according to API structure
    const formValues = this.signupForm.value;
    const signupRequest: SignupRequest = {
      firstName: formValues.firstName,
      lastName: formValues.lastName,
      email: formValues.email,
      phoneNumber: `${formValues.countryCode}${formValues.phone}`,
      city: formValues.city,
      birthOfDate: formValues.dob,
      password: formValues.password,
      confirmPassword: formValues.confirmPassword,
      isTermsAccepted: formValues.terms
    };

    // Call the signup API
    this.authService.signup(signupRequest).subscribe({
      next: (response) => {
        this.isLoading = false;
        
        // Show success message and redirect to OTP verification
        Swal.fire({
          icon: 'success',
          title: 'Registration Successful',
          text: 'Account created successfully! Please check your email for the OTP verification code.',
          confirmButtonColor: '#08227B',
          confirmButtonText: 'Continue to Verification'
        }).then(() => {
          // Navigate to OTP verification page with the email
          this.router.navigate(['/otp-verification'], { 
            queryParams: { 
              email: formValues.email,
              type: 'signup' // ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ù„ØªÙ…ÙŠÙŠØ² Ù†ÙˆØ¹ OTP verification
            } 
          });
        });
      },
      error: (error) => {
        this.isLoading = false;
        console.error('Signup error:', error);
        
        // Handle different types of errors
        let errorMessage = 'Registration failed. Please try again.';
        
        if (error.status === 400) {
          // Handle validation errors
          if (error.error && error.error.errors) {
            const validationErrors = error.error.errors;
            const errorMessages = [];
            
            // Extract validation error messages
            for (const field in validationErrors) {
              if (validationErrors[field] && Array.isArray(validationErrors[field])) {
                errorMessages.push(...validationErrors[field]);
              }
            }
            
            if (errorMessages.length > 0) {
              errorMessage = errorMessages.join('\n');
            }
          } else if (error.error && error.error.message) {
            errorMessage = error.error.message;
          }
        } else if (error.status === 409) {
          errorMessage = 'An account with this email already exists.';
        } else if (error.status === 0) {
          errorMessage = 'Unable to connect to server. Please check your internet connection.';
        }

        Swal.fire({
          icon: 'error',
          title: 'Registration Failed',
          text: errorMessage,
          confirmButtonColor: '#08227B'
        });
      }
    });
  }

  togglePasswordVisibility(): void {
    this.showPassword = !this.showPassword;
  }

  toggleConfirmPasswordVisibility(): void {
    this.showConfirmPassword = !this.showConfirmPassword;
  }

  signupWithGoogle(): void {
    // Google signup implementation will be added later
    Swal.fire({
      icon: 'info',
      title: 'Coming Soon',
      text: 'Google signup will be available in a future update.',
      confirmButtonColor: '#08227B'
    });
  }

  goToHome(): void {
    this.router.navigate(['/log-in']);
  }
}


================================================
File: assets/.gitkeep
================================================



================================================
File: assets/images/background.webp
================================================
[Non-text file]

